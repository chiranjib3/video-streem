<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Call Room - {{ room_id }}</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #0a2545 100%);
            margin: 0;
            padding: 0;
            min-height: 100vh;
            color: #ffffff;
            overflow-x: hidden;
            position: relative;
            background-attachment: fixed;
        }
        
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                radial-gradient(circle at 20% 50%, rgba(120, 119, 198, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 80% 20%, rgba(255, 119, 198, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 40% 80%, rgba(120, 219, 255, 0.15) 0%, transparent 50%),
                radial-gradient(circle at 60% 30%, rgba(100, 255, 180, 0.1) 0%, transparent 40%);
            z-index: -1;
            animation: backgroundShift 15s ease-in-out infinite;
        }
        
        body::after {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: 
                repeating-linear-gradient(
                    90deg,
                    transparent,
                    transparent 98px,
                    rgba(255, 255, 255, 0.01) 100px
                ),
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 98px,
                    rgba(255, 255, 255, 0.01) 100px
                );
            z-index: -1;
            pointer-events: none;
        }
        
        @keyframes backgroundShift {
            0%, 100% { 
                transform: translateY(0px) rotate(0deg) scale(1); 
                opacity: 1;
            }
            33% { 
                transform: translateY(-15px) rotate(1deg) scale(1.02); 
                opacity: 0.9;
            }
            66% { 
                transform: translateY(10px) rotate(-0.5deg) scale(0.98); 
                opacity: 0.95;
            }
        }
        
        .container {
            max-width: 1800px;
            margin: 0 auto;
            padding: 24px;
            display: grid;
            grid-template-columns: 1fr; /* Full width since chat floats above */
            gap: 0px;
            align-items: start;
            min-height: 100vh;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            position: relative;
            /* Ensure container doesn't interfere with zoom overlay */
            z-index: auto;
        }
        
        /* Main content now takes full width since chat floats */
        .main-content {
            min-width: 0;
            display: flex;
            flex-direction: column;
            gap: 20px;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            width: 100%;
            max-width: 100%;
            position: relative;
            z-index: 1; /* Behind floating chat */
        }
        
        .container.chat-collapsed .main-content {
            transform: perspective(1000px) scale(1.05);
        }
        
        .container.chat-expanded .main-content {
            transform: perspective(1000px) scale(0.98);
        }
        
        .container.fullscreen-video .main-content {
            transform: perspective(1000px) scale(1.1);
            gap: 24px;
        }
        
        .chat-sidebar {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 28px;
            padding: 32px;
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            height: calc(100vh - 48px);
            display: flex;
            flex-direction: column;
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.6s cubic-bezier(0.4, 0, 0.2, 1);
            width: 420px;
            min-width: 420px;
            overflow: hidden;
            /* Simple Floating Chat Above Main Content - No 3D */
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 9999999;
        }
        
        /* Foreground chat icon inside the chat sidebar */
        .chat-foreground-icon {
            position: absolute;
            top: 20px;
            left: 20px;
            width: 50px;
            height: 50px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            color: white;
            box-shadow: 
                0 10px 25px rgba(102, 126, 234, 0.3),
                0 0 0 3px rgba(255, 255, 255, 0.1);
            animation: chatPulse 2s ease-in-out infinite;
            z-index: 10000000;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        .chat-foreground-icon:hover {
            transform: scale(1.1);
            box-shadow: 
                0 15px 35px rgba(102, 126, 234, 0.5),
                0 0 0 5px rgba(255, 255, 255, 0.2);
        }
        
        @keyframes chatPulse {
            0%, 100% { 
                box-shadow: 
                    0 10px 25px rgba(102, 126, 234, 0.3),
                    0 0 0 3px rgba(255, 255, 255, 0.1),
                    0 0 0 0px rgba(102, 126, 234, 0.3);
            }
            50% { 
                box-shadow: 
                    0 15px 35px rgba(102, 126, 234, 0.4),
                    0 0 0 3px rgba(255, 255, 255, 0.2),
                    0 0 0 10px rgba(102, 126, 234, 0.1);
            }
        }
        
        .chat-sidebar.collapsed {
            width: 80px;
            min-width: 80px;
            padding: 20px;
            display: flex;
            align-items: flex-start;
            justify-content: center;
            position: relative;
            transform: perspective(1000px) rotateY(-8deg) scale(0.9);
            opacity: 0.8;
        }
        
        /* Mobile-specific override for collapsed chat */
        @media (max-width: 768px) {
            .chat-sidebar.collapsed {
                transform: none !important;
                opacity: 1;
            }
        }
        
        .chat-sidebar.expanded {
            width: 450px;
            min-width: 450px;
            padding: 36px;
        }
        
        .chat-sidebar.collapsed {
            width: 80px;
            min-width: 80px;
            padding: 20px 16px;
            opacity: 0.8;
        }
        
        .chat-sidebar.hidden {
            width: 0px;
            min-width: 0px;
            padding: 0px;
            margin: 0px;
            opacity: 0;
            pointer-events: none;
        }
        
        /* Simple hover effects - no 3D */
        .chat-sidebar:hover {
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.2),
                0 0 0 2px rgba(255, 255, 255, 0.1),
                inset 0 2px 0 rgba(255, 255, 255, 0.15);
        }
        
        /* Foreground glow effect for chat sidebar */
        .chat-sidebar::before {
            content: '';
            position: absolute;
            top: -5px;
            left: -5px;
            right: -5px;
            bottom: -5px;
            background: linear-gradient(135deg, 
                rgba(102, 126, 234, 0.1), 
                rgba(118, 75, 162, 0.1));
            border-radius: 33px;
            z-index: -1;
            opacity: 0.6;
            animation: foregroundGlow 3s ease-in-out infinite alternate;
            pointer-events: none;
        }
        
        /* Force chat to absolute foreground */
        .chat-sidebar {
            position: relative !important;
            isolation: isolate;
            will-change: transform;
        }
        
        .chat-sidebar * {
            position: relative;
            z-index: inherit;
        }
        
        @keyframes foregroundGlow {
            0% { 
                opacity: 0.3;
                transform: scale(1);
            }
            100% { 
                opacity: 0.7;
                transform: scale(1.02);
            }
        }
        
        .chat-sidebar.collapsed .chat-content {
            opacity: 0;
            pointer-events: none;
            transform: translateX(30px) scale(0.9);
            transition: all 0.4s ease;
            display: none;
        }
        
        .chat-sidebar.collapsed .chat-toggle-btn {
            transform: rotate(180deg);
            position: static;
            margin: 0;
        }
        
        .chat-header-content,
        .chat-messages,
        .typing-indicator,
        .chat-input-container {
            transition: all 0.3s ease;
        }
        
        .chat-sidebar:hover {
            transform: translateY(-3px);
            box-shadow: 
                0 35px 70px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        .chat-sidebar.collapsed:hover {
            transform: perspective(1000px) rotateY(0deg) translateY(-3px);
        }
        
        .chat-header {
            margin-bottom: 24px;
            padding-bottom: 20px;
            padding-top: 70px; /* Space for foreground chat icon */
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            position: relative;
        }
        
        .chat-header::after {
            content: '';
            position: absolute;
            bottom: -1px;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 2px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            border-radius: 1px;
        }
        
        .chat-header-content {
            text-align: center;
        }
        
        .chat-toggle-btn {
            background: rgba(255, 255, 255, 0.12);
            border: 1px solid rgba(255, 255, 255, 0.25);
            border-radius: 12px;
            color: white;
            font-size: 18px;
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            backdrop-filter: blur(15px);
            flex-shrink: 0;
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 100;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
        }
        
        .chat-content {
            display: flex;
            flex-direction: column;
            height: 100%;
            transition: all 0.4s ease;
            overflow: visible;
            padding-bottom: 12px;
            min-height: 0;
            position: relative;
            background: linear-gradient(135deg, 
                rgba(255, 255, 255, 0.02) 0%, 
                rgba(255, 255, 255, 0.05) 50%, 
                rgba(255, 255, 255, 0.02) 100%);
            border-radius: 24px;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .chat-toggle-btn:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.1) rotate(5deg);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.2);
        }
        
        /* Mobile-specific improvements for floating chat - no 3D */
        @media (max-width: 768px) {
            .chat-sidebar {
                position: fixed;
                top: 20px;
                right: 20px;
                width: 320px;
                min-width: 320px;
                height: calc(100vh - 60px);
                max-height: calc(100vh - 60px);
                z-index: 9999999;
            }
            
            .chat-sidebar:hover {
                box-shadow: 
                    0 35px 70px rgba(0, 0, 0, 0.25),
                    0 0 0 2px rgba(255, 255, 255, 0.12);
            }
            
            .chat-sidebar.collapsed {
                width: 60px;
                min-width: 60px;
            }
            
            .main-content {
                width: 100%;
                max-width: 100%;
                padding-right: 0; /* No need to account for chat since it floats */
            }
            
            .chat-foreground-icon {
                top: 15px;
                left: 15px;
                width: 45px;
                height: 45px;
                font-size: 20px;
                z-index: 10000000;
            }
            
            /* Improved mobile chat layout */
            .chat-sidebar {
                display: flex !important;
                flex-direction: column !important;
            }
            
            .chat-messages {
                flex-grow: 1 !important;
                overflow-y: auto !important;
                -webkit-overflow-scrolling: touch !important;
            }
            
            .chat-header {
                padding-top: 65px; /* Adjusted for mobile */
            }
            
            .chat-toggle-btn {
                /* Enhanced mobile touch support */
                transform: none !important;
                transition: background-color 0.3s ease, opacity 0.3s ease, transform 0.2s ease;
                z-index: 10000001; /* Ensure toggle button is above everything */
                /* Make button more touch-friendly on mobile */
                width: 50px !important;
                height: 50px !important;
                font-size: 20px !important;
                border-radius: 25px !important;
                /* Improve touch target */
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
                /* Ensure button is always clickable */
                pointer-events: auto !important;
                cursor: pointer !important;
            }
            
            .chat-toggle-btn:hover {
                transform: none !important;
                background: rgba(255, 255, 255, 0.3) !important;
            }
            
            .chat-toggle-btn:active {
                background: rgba(255, 255, 255, 0.5) !important;
                opacity: 0.9 !important;
                transform: scale(0.95) !important;
            }
            
            /* Fix for mobile touch events */
            .chat-toggle-btn:focus {
                outline: 2px solid rgba(255, 255, 255, 0.5);
                outline-offset: 2px;
            }
            
            /* Ensure button is always on top and clickable on mobile */
            .chat-sidebar .chat-toggle-btn {
                position: absolute !important;
                top: 16px !important;
                right: 16px !important;
                z-index: 10000001 !important;
                display: block !important;
                visibility: visible !important;
                opacity: 1 !important;
                pointer-events: auto !important;
            }
            
            /* Mobile-specific chat sidebar positioning */
            .chat-sidebar {
                position: fixed !important;
                top: 20px !important;
                right: 20px !important;
                z-index: 9999999 !important;
            }
        }
        
        .chat-header h3 {
            font-size: 20px;
            font-weight: 700;
            margin-bottom: 12px;
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
            position: relative;
        }
        
        .chat-header h3::after {
            content: 'ðŸ’¬';
            position: absolute;
            left: -30px;
            top: 0;
            font-size: 18px;
            animation: float 3s ease-in-out infinite;
        }
        
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-5px); }
        }
        
        .chat-messages {
            flex: 1;
            overflow-y: auto;
            margin-bottom: 24px;
            padding: 20px;
            background: rgba(0, 0, 0, 0.15);
            border-radius: 20px;
            max-height: 500px;
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) transparent;
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: inset 0 4px 12px rgba(0, 0, 0, 0.1);
        }
        
        .chat-messages::-webkit-scrollbar {
            width: 6px;
        }
        
        .chat-messages::-webkit-scrollbar-track {
            background: transparent;
        }
        
        .chat-messages::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 3px;
        }
        
        .chat-messages::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .message {
            margin-bottom: 16px;
            text-align: left;
            padding: 16px 20px;
            border-radius: 20px;
            word-wrap: break-word;
            animation: messageSlideIn 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.05);
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .message:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
        }
        
        @keyframes messageSlideIn {
            from {
                opacity: 0;
                transform: translateY(15px) scale(0.95);
            }
            to {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
        }
        
        .message.user {
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.25), rgba(33, 150, 243, 0.15));
            margin-left: 24px;
            border-left: 4px solid #2196F3;
            box-shadow: 0 0 20px rgba(33, 150, 243, 0.1);
        }
        
        .message.own {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.25), rgba(76, 175, 80, 0.15));
            margin-right: 24px;
            margin-left: 48px;
            border-left: 4px solid #4CAF50;
            box-shadow: 0 0 20px rgba(76, 175, 80, 0.1);
        }
        
        .message.system {
            background: linear-gradient(135deg, rgba(255, 255, 255, 0.12), rgba(255, 255, 255, 0.08));
            text-align: center;
            font-style: italic;
            margin: 12px 24px;
            border-left: 4px solid #667eea;
            box-shadow: 0 0 20px rgba(102, 126, 234, 0.1);
        }
        
        .message-header {
            font-size: 11px;
            opacity: 0.8;
            margin-bottom: 4px;
            font-weight: 500;
        }
        
        .message-content {
            font-size: 14px;
            line-height: 1.5;
            font-weight: 400;
        }
        
        .chat-input-container {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 12px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.1);
            min-height: 60px;
            overflow: visible;
            width: 100%;
            box-sizing: border-box;
            position: relative;
            z-index: 5;
        }
        
        /* Ensure all buttons in chat are fully visible */
        .chat-input-container > * {
            flex-shrink: 0;
            overflow: visible;
        }
        
        .chat-input {
            flex: 1;
            padding: 12px 18px;
            border: none;
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.08);
            color: white;
            font-size: 15px;
            font-family: inherit;
            transition: all 0.3s ease;
            outline: none;
            height: 48px;
            min-height: 48px;
            max-height: 48px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-sizing: border-box;
            flex-shrink: 1;
            min-width: 150px;
        }
        
        .chat-input::placeholder {
            color: rgba(255, 255, 255, 0.6);
        }
        
        .chat-input:focus {
            outline: none;
            background: rgba(255, 255, 255, 0.12);
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }
        
        .chat-send-btn {
            padding: 12px 16px;
            border: none;
            border-radius: 25px;
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            min-width: 48px;
            max-width: 48px;
            min-height: 48px;
            max-height: 48px;
            box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);
            flex-shrink: 0;
            flex-grow: 0;
            white-space: nowrap;
            z-index: 10;
            position: relative;
            overflow: visible;
            box-sizing: border-box;
        }
        
        .chat-send-btn:hover {
            transform: translateY(-3px) scale(1.05);
            box-shadow: 0 8px 30px rgba(102, 126, 234, 0.4);
            background: linear-gradient(135deg, #5a67d8, #667eea);
        }
        
        .chat-send-btn:active {
            transform: translateY(-1px) scale(1.02);
        }
        
        .chat-send-btn:disabled {
            background: rgba(255, 255, 255, 0.2);
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }
        
        /* Force chat send button to be fully visible */
        #chatSendBtn {
            width: 48px !important;
            height: 48px !important;
            min-width: 48px !important;
            max-width: 48px !important;
            min-height: 48px !important;
            max-height: 48px !important;
            flex-shrink: 0 !important;
            flex-grow: 0 !important;
            flex-basis: 48px !important;
            overflow: visible !important;
            visibility: visible !important;
            display: flex !important;
            position: relative !important;
            z-index: 10 !important;
        }
        
        /* File sharing styles */
        .file-upload-btn {
            padding: 12px;
            background: rgba(76, 175, 80, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            min-width: 48px;
            max-width: 48px;
            min-height: 48px;
            max-height: 48px;
            flex-shrink: 0;
            flex-grow: 0;
            box-sizing: border-box;
        }
        
        .file-upload-btn:hover {
            background: rgba(76, 175, 80, 0.9);
            transform: scale(1.05);
        }
        
        .file-upload-btn:active {
            transform: scale(0.95);
        }
        
        .file-input {
            display: none;
        }
        
        .file-message {
            background: rgba(76, 175, 80, 0.1);
            border: 1px solid rgba(76, 175, 80, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin: 5px 0;
        }
        
        .file-info {
            display: flex;
            align-items: center;
            gap: 12px;
            text-decoration: none;
            color: inherit;
        }
        
        .file-icon {
            font-size: 24px;
            min-width: 32px;
            text-align: center;
        }
        
        .file-details {
            flex: 1;
        }
        
        .file-name {
            font-weight: 500;
            margin-bottom: 4px;
            word-break: break-word;
        }
        
        .file-meta {
            font-size: 12px;
            color: rgba(255, 255, 255, 0.7);
        }
        
        .file-download-btn {
            padding: 8px 16px;
            background: rgba(76, 175, 80, 0.7);
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }
        
        .file-download-btn:hover {
            background: rgba(76, 175, 80, 0.9);
            transform: translateY(-1px);
        }
        
        .upload-progress {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 15px 20px;
            border-radius: 10px;
            z-index: 1000;
            min-width: 200px;
        }
        
        .upload-progress.hidden {
            display: none;
        }
        
        .progress-bar {
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-top: 10px;
            overflow: hidden;
        }
        
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A);
            width: 0%;
            transition: width 0.3s ease;
        }
        
        /* Voice chat styles */
        .voice-record-btn {
            padding: 12px;
            background: rgba(244, 67, 54, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 16px;
            transition: all 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 48px;
            height: 48px;
            min-width: 48px;
            max-width: 48px;
            min-height: 48px;
            max-height: 48px;
            flex-shrink: 0;
            flex-grow: 0;
            box-sizing: border-box;
        }
        
        .voice-record-btn:hover {
            background: rgba(244, 67, 54, 0.9);
            transform: scale(1.05);
        }
        
        .voice-record-btn.recording {
            background: rgba(244, 67, 54, 1);
            animation: recordingPulse 1.5s infinite;
        }
        
        @keyframes recordingPulse {
            0%, 100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(244, 67, 54, 0.7); }
            50% { transform: scale(1.05); box-shadow: 0 0 0 10px rgba(244, 67, 54, 0); }
        }
        
        .voice-message {
            background: rgba(63, 81, 181, 0.1);
            border: 1px solid rgba(63, 81, 181, 0.3);
            border-radius: 20px;
            padding: 12px 16px;
            margin: 5px 0;
            display: flex;
            align-items: center;
            gap: 12px;
            max-width: 300px;
        }
        
        .voice-play-btn {
            background: rgba(63, 81, 181, 0.7);
            border: none;
            border-radius: 50%;
            color: white;
            cursor: pointer;
            font-size: 14px;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }
        
        .voice-play-btn:hover {
            background: rgba(63, 81, 181, 0.9);
            transform: scale(1.1);
        }
        
        .voice-play-btn.playing {
            background: rgba(255, 152, 0, 0.7);
        }
        
        .voice-waveform {
            flex: 1;
            height: 32px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            position: relative;
            overflow: hidden;
        }
        
        .voice-progress {
            height: 100%;
            background: linear-gradient(90deg, #3F51B5, #2196F3);
            border-radius: 16px;
            width: 0%;
            transition: width 0.1s ease;
        }
        
        .voice-duration {
            font-size: 11px;
            color: rgba(255, 255, 255, 0.7);
            min-width: 35px;
            text-align: center;
        }
        
        .recording-indicator {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 20px 30px;
            border-radius: 20px;
            z-index: 1000;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
        }
        
        .recording-indicator.hidden {
            display: none;
        }
        
        .recording-wave {
            display: flex;
            gap: 3px;
            align-items: center;
            height: 40px;
        }
        
        .recording-bar {
            width: 4px;
            background: #f44336;
            border-radius: 2px;
            animation: recordingWave 1.5s infinite ease-in-out;
        }
        
        .recording-bar:nth-child(2) { animation-delay: 0.1s; }
        .recording-bar:nth-child(3) { animation-delay: 0.2s; }
        .recording-bar:nth-child(4) { animation-delay: 0.3s; }
        .recording-bar:nth-child(5) { animation-delay: 0.4s; }
        
        @keyframes recordingWave {
            0%, 100% { height: 8px; }
            50% { height: 32px; }
        }
        
        .recording-time {
            font-size: 18px;
            font-weight: 500;
        }
        
        .recording-controls {
            display: flex;
            gap: 15px;
        }
        
        .recording-control-btn {
            padding: 10px 20px;
            border: none;
            border-radius: 20px;
            color: white;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.3s ease;
        }
        
        .recording-control-btn.stop {
            background: #f44336;
        }
        
        .recording-control-btn.cancel {
            background: #757575;
        }
        
        .recording-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
        }
        
        .typing-indicator {
            font-size: 12px;
            opacity: 0.7;
            font-style: italic;
            padding: 8px 16px;
            min-height: 24px;
            color: #667eea;
            animation: typingPulse 1.5s infinite;
        }
        
        @keyframes typingPulse {
            0%, 100% { opacity: 0.7; }
            50% { opacity: 1; }
        }
        
        .room-header {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 28px;
            padding: 32px;
            margin-bottom: 32px;
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            text-align: center;
            position: relative;
            overflow: hidden;
        }
        
        .room-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.1), transparent);
            transition: left 1s ease;
        }
        
        .room-header:hover::before {
            left: 100%;
        }
        
        .room-header:hover {
            transform: translateY(-4px);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.2),
                0 0 0 1px rgba(255, 255, 255, 0.08),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        .room-title {
            font-size: 32px;
            font-weight: 800;
            margin-bottom: 16px;
            background: linear-gradient(135deg, #667eea, #764ba2, #f093fb, #f5576c);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            background-size: 300% 300%;
            animation: gradientShift 8s ease infinite;
            text-shadow: 0 0 30px rgba(102, 126, 234, 0.3);
            position: relative;
        }
        
        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }
        
        .room-title::after {
            content: 'ðŸŽ¥';
            position: absolute;
            top: -10px;
            right: -40px;
            font-size: 24px;
            animation: bounce 2s infinite;
        }
        
        @keyframes bounce {
            0%, 20%, 50%, 80%, 100% { transform: translateY(0); }
            40% { transform: translateY(-10px); }
            60% { transform: translateY(-5px); }
        }
        
        .room-id {
            font-size: 18px;
            margin-bottom: 20px;
            opacity: 0.9;
            font-weight: 600;
        }
        
        .room-id-value {
            font-family: 'JetBrains Mono', 'Fira Code', monospace;
            background: rgba(255, 255, 255, 0.15);
            padding: 12px 24px;
            border-radius: 16px;
            display: inline-block;
            margin: 0 12px;
            font-weight: 700;
            letter-spacing: 2px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
        }
        
        .room-id-value::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }
        
        .room-id-value:hover::before {
            left: 100%;
        }
        
        .room-id-value:hover {
            background: rgba(255, 255, 255, 0.25);
            transform: scale(1.05) translateY(-2px);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
        }
        
        .video-grid {
            display: grid;
            gap: 16px;
            margin: 24px 0;
            height: calc(100vh - 200px);
            padding: 12px;
            width: 100%;
            /* Dynamic grid layout - will be set by JavaScript */
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-items: center;
            justify-items: center;
            transition: all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            transform-style: preserve-3d;
            /* Ensure video grid stays behind chat */
            z-index: 1;
            position: relative;
            /* Add scroll functionality when content overflows */
            overflow-y: auto;
            overflow-x: hidden;
            /* Custom scrollbar styling */
            scrollbar-width: thin;
            scrollbar-color: rgba(255, 255, 255, 0.3) rgba(255, 255, 255, 0.1);
            /* Ensure grid doesn't interfere with zoom overlay */
            position: relative;
            z-index: 1;
        }
        
        /* Custom scrollbar for webkit browsers */
        .video-grid::-webkit-scrollbar {
            width: 8px;
        }
        
        .video-grid::-webkit-scrollbar-track {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .video-grid::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.3);
            border-radius: 10px;
            transition: background 0.3s ease;
        }
        
        .video-grid::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.5);
        }
        
        .container.chat-collapsed .video-grid {
            height: calc(100vh - 180px);
            gap: 20px;
            transform: scale(1.02);
        }
        
        .container.chat-expanded .video-grid {
            height: calc(100vh - 220px);
            gap: 14px;
            transform: scale(0.98);
        }
        
        .container.fullscreen-video .video-grid {
            height: calc(100vh - 160px);
            gap: 24px;
            transform: scale(1.05);
            margin: 32px 0;
        }
        
        /* Grid layouts for different participant counts - improved serial arrangement */
        .video-grid.participants-1 {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr;
            align-content: center;
        }
        
        .video-grid.participants-2 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr;
            align-content: center;
        }
        
        .video-grid.participants-3 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            align-content: start;
        }
        
        .video-grid.participants-4 {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            align-content: center;
        }
        
        .video-grid.participants-5,
        .video-grid.participants-6 {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            align-content: start;
        }
        
        .video-grid.participants-7,
        .video-grid.participants-8,
        .video-grid.participants-9 {
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr);
            align-content: start;
            height: auto;
            min-height: calc(100vh - 200px);
        }
        
        .video-grid.participants-10,
        .video-grid.participants-11,
        .video-grid.participants-12 {
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
            align-content: start;
            height: auto;
            min-height: calc(100vh - 200px);
        }
        
        .video-grid.participants-13,
        .video-grid.participants-14,
        .video-grid.participants-15,
        .video-grid.participants-16 {
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(4, 1fr);
            align-content: start;
            height: auto;
            min-height: calc(100vh - 200px);
        }
        
        .video-grid.participants-more {
            grid-template-columns: repeat(5, 1fr);
            grid-template-rows: repeat(auto-fit, minmax(180px, 1fr));
            align-content: start;
            height: auto;
            min-height: calc(100vh - 200px);
            grid-auto-rows: minmax(180px, 1fr);
        }
        
        /* Special handling for 3 participants - 2 on top, 1 centered below */
        .video-grid.participants-3 .video-container:nth-child(3) {
            grid-column: 1 / -1;
            justify-self: center;
            max-width: 50%;
        }
        
        /* Removed scrollbar CSS since grid now auto-adjusts without scrolling */
        
        .video-container {
            position: relative;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.4), rgba(0, 0, 0, 0.2));
            border-radius: 24px;
            overflow: hidden;
            aspect-ratio: 16/9;
            border: 2px solid rgba(255, 255, 255, 0.12);
            transition: all 0.5s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            backdrop-filter: blur(15px);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.25),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            width: 100%;
            height: 100%;
            min-width: 180px;
            min-height: 120px;
            max-width: 100%;
            transform-style: preserve-3d;
            /* Ensure proper sizing in scrollable grid */
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        /* Responsive video container sizing based on participant count */
        .video-grid.participants-1 .video-container,
        .video-grid.participants-2 .video-container,
        .video-grid.participants-3 .video-container,
        .video-grid.participants-4 .video-container {
            min-width: 220px;
            min-height: 140px;
        }
        
        .video-grid.participants-5 .video-container,
        .video-grid.participants-6 .video-container,
        .video-grid.participants-7 .video-container,
        .video-grid.participants-8 .video-container,
        .video-grid.participants-9 .video-container {
            min-width: 200px;
            min-height: 120px;
        }
        
        .video-grid.participants-10 .video-container,
        .video-grid.participants-11 .video-container,
        .video-grid.participants-12 .video-container,
        .video-grid.participants-13 .video-container,
        .video-grid.participants-14 .video-container,
        .video-grid.participants-15 .video-container,
        .video-grid.participants-16 .video-container {
            min-width: 180px;
            min-height: 110px;
        }
        
        .video-grid.participants-more .video-container {
            min-width: 160px;
            min-height: 100px;
        }
        
        .video-container:hover {
            border-color: rgba(102, 126, 234, 0.6);
            transform: translateY(-6px) scale(1.02) perspective(1000px) rotateX(2deg);
            box-shadow: 
                0 25px 50px rgba(0, 0, 0, 0.35),
                0 0 0 1px rgba(102, 126, 234, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }
        
        /* Zoom functionality styles - Fixed for proper layering and centering */
        .video-zoom-overlay {
            position: fixed !important;
            top: 0 !important;
            left: 0 !important;
            width: 100vw !important;
            height: 100vh !important;
            background: rgba(0, 0, 0, 0.95) !important;
            backdrop-filter: blur(15px) !important;
            z-index: 999999 !important;
            display: none;
            align-items: center !important;
            justify-content: center !important;
            animation: fadeIn 0.3s ease;
            pointer-events: none;
            /* Ensure it's always on top */
            isolation: isolate;
        }
        
        .video-zoom-overlay.active {
            display: flex !important;
            pointer-events: all !important;
        }
        
        .video-zoom-container {
            position: absolute !important;
            width: 80vw;
            height: 70vh;
            max-width: 1200px;
            max-height: 800px;
            min-width: 600px;
            min-height: 400px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.6), rgba(0, 0, 0, 0.3));
            border-radius: 24px;
            overflow: hidden;
            border: 3px solid rgba(102, 126, 234, 0.8);
            box-shadow: 
                0 30px 60px rgba(0, 0, 0, 0.6),
                0 0 0 1px rgba(255, 255, 255, 0.1),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            animation: zoomIn 0.4s ease forwards;
            display: flex;
            align-items: center;
            justify-content: center;
            /* Perfect absolute centering */
            top: 50% !important;
            left: 50% !important;
            transform: translate(-50%, -50%) scale(0.8) !important;
            z-index: 1000000 !important;
        }
        
        .video-zoom-container video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            border-radius: 20px;
        }
        
        .video-zoom-controls {
            position: absolute;
            top: 20px;
            right: 20px;
            display: flex;
            gap: 12px;
            z-index: 10001;
        }
        
        .video-zoom-btn {
            background: rgba(0, 0, 0, 0.7);
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            width: 50px;
            height: 50px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 18px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .video-zoom-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.1);
        }
        
        .video-zoom-info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            background: rgba(0, 0, 0, 0.8);
            padding: 12px 20px;
            border-radius: 20px;
            color: white;
            font-size: 14px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .video-zoom-info h4 {
            margin: 0 0 4px 0;
            font-size: 16px;
            color: #667eea;
        }
        
        .video-zoom-info p {
            margin: 0;
            opacity: 0.8;
            font-size: 12px;
        }
        
        /* Zoom button on video containers */
        .video-container .zoom-btn {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            color: white;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 14px;
            opacity: 0;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            z-index: 10;
        }
        
        .video-container:hover .zoom-btn {
            opacity: 1;
            transform: scale(1.1);
        }
        
        .video-container .zoom-btn:hover {
            background: rgba(102, 126, 234, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
            transform: scale(1.2);
        }
        
        /* Selected video container state */
        .video-container.selected {
            border-color: rgba(102, 126, 234, 0.8);
            box-shadow: 
                0 20px 40px rgba(0, 0, 0, 0.3),
                0 0 0 3px rgba(102, 126, 234, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.15);
            transform: translateY(-2px) scale(1.05);
        }
        
        .video-container.selected .zoom-btn {
            opacity: 1;
            background: rgba(102, 126, 234, 0.9);
            border-color: rgba(255, 255, 255, 0.8);
        }
        
        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }
        
        @keyframes zoomIn {
            from { 
                transform: translate(-50%, -50%) scale(0.5) !important;
                opacity: 0;
            }
            to { 
                transform: translate(-50%, -50%) scale(1) !important;
                opacity: 1;
            }
        }
        
        @keyframes zoomOut {
            from { 
                transform: translate(-50%, -50%) scale(1) !important;
                opacity: 1;
            }
            to { 
                transform: translate(-50%, -50%) scale(0.5) !important;
                opacity: 0;
            }
        }
        
        /* Mobile zoom adjustments */
        @media (max-width: 768px) {
            .video-zoom-container {
                width: 95vw !important;
                height: 60vh !important;
                min-width: 320px !important;
                min-height: 240px !important;
                border-radius: 16px !important;
                /* Ensure perfect centering on mobile - force above grid */
                position: absolute !important;
                top: 50% !important;
                left: 50% !important;
                transform: translate(-50%, -50%) scale(0.8) !important;
                z-index: 1000001 !important;
            }
            
            /* Mobile-specific animations */
            @keyframes zoomIn {
                from { 
                    transform: translate(-50%, -50%) scale(0.4) !important;
                    opacity: 0;
                }
                to { 
                    transform: translate(-50%, -50%) scale(1) !important;
                    opacity: 1;
                }
            }
            
            @keyframes zoomOut {
                from { 
                    transform: translate(-50%, -50%) scale(1) !important;
                    opacity: 1;
                }
                to { 
                    transform: translate(-50%, -50%) scale(0.4) !important;
                    opacity: 0;
                }
            }
            
            .video-zoom-controls {
                top: 10px;
                right: 10px;
                gap: 8px;
                z-index: 1000002 !important;
            }
            
            .video-zoom-btn {
                width: 40px;
                height: 40px;
                font-size: 16px;
                z-index: 1000003 !important;
            }
            
            .video-zoom-info {
                bottom: 10px;
                left: 10px;
                padding: 8px 16px;
                font-size: 12px;
                z-index: 1000002 !important;
            }
            
            .video-zoom-info h4 {
                font-size: 14px;
            }
            
            .video-container .zoom-btn {
                width: 28px;
                height: 28px;
                font-size: 12px;
                top: 6px;
                right: 6px;
            }
        }
        
        /* Very small screens - ensure perfect centering */
        @media (max-width: 480px) {
            .video-zoom-container {
                width: 98vw !important;
                height: 50vh !important;
                min-width: 280px !important;
                min-height: 200px !important;
                border-radius: 12px !important;
                /* Extra perfect centering for small screens - force above everything */
                position: absolute !important;
                top: 50vh !important;
                left: 50vw !important;
                transform: translate(-50%, -50%) scale(0.8) !important;
                z-index: 1000002 !important;
            }
            
            .video-zoom-controls {
                top: 8px;
                right: 8px;
                gap: 6px;
                z-index: 1000003 !important;
            }
            
            .video-zoom-btn {
                width: 36px;
                height: 36px;
                font-size: 14px;
                z-index: 1000004 !important;
            }
            
            .video-zoom-info {
                bottom: 8px;
                left: 8px;
                padding: 6px 12px;
                font-size: 11px;
                z-index: 1000003 !important;
            }
        }
        
        .video-container.focused {
            transform: scale(1.6);
            z-index: 1000;
            border-color: #667eea;
            box-shadow: 0 25px 50px rgba(102, 126, 234, 0.4);
        }
        
        .video-container.focused:hover {
            transform: scale(1.6);
        }
        
        .video-container.speaking {
            border-color: #4CAF50;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            animation: speakingGlow 2s infinite;
        }
        
        @keyframes speakingGlow {
            0%, 100% { 
                box-shadow: 0 0 30px rgba(76, 175, 80, 0.6);
            }
            50% { 
                box-shadow: 0 0 40px rgba(76, 175, 80, 0.8);
            }
        }
        
        .video-container.speaking.focused {
            border-color: #667eea;
            box-shadow: 0 25px 50px rgba(102, 126, 234, 0.4);
        }
        
        .video-container.local {
            border-color: #2196F3;
            cursor: default;
        }
        
        .video-container.local:hover {
            transform: translateY(-2px);
            border-color: #2196F3;
        }
        
        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            background: linear-gradient(135deg, #1a1a2e, #16213e);
        }
        
        .video-overlay {
            position: absolute;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.85), rgba(0, 0, 0, 0.7));
            border-radius: 16px;
            padding: 16px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
            transition: all 0.3s ease;
        }
        
        .video-overlay:hover {
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.9), rgba(0, 0, 0, 0.8));
            transform: translateY(-2px);
        }
        
        .user-name {
            color: white;
            font-size: 15px;
            font-weight: 700;
            text-shadow: 0 2px 8px rgba(0, 0, 0, 0.7);
            letter-spacing: 0.5px;
        }
        
        .media-indicators {
            display: flex;
            gap: 8px;
        }
        
        .media-indicator {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
        }
        
        .audio-indicator.muted {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            animation: indicatorPulse 2s infinite;
        }
        
        .audio-indicator.active {
            background: linear-gradient(135deg, #4CAF50, #388e3c);
        }
        
        .video-indicator.muted {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            animation: indicatorPulse 2s infinite;
        }
        
        .video-indicator.active {
            background: linear-gradient(135deg, #2196F3, #1976d2);
        }
        
        .force-mute-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #ff5722, #d84315);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.3s ease;
            opacity: 0.8;
            backdrop-filter: blur(10px);
        }
        
        .force-mute-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(255, 87, 34, 0.4);
        }
        
        .force-mute-btn.active {
            background: linear-gradient(135deg, #f44336, #d32f2f);
            animation: indicatorPulse 2s infinite;
        }
        
        .kick-ban-btn {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: linear-gradient(135deg, #e91e63, #c2185b);
            border: none;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 10px;
            transition: all 0.3s ease;
            opacity: 0.8;
            backdrop-filter: blur(10px);
        }
        
        .kick-ban-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            box-shadow: 0 2px 8px rgba(233, 30, 99, 0.4);
        }
        
        .kick-ban-btn.banned {
            background: linear-gradient(135deg, #795548, #5d4037);
            cursor: not-allowed;
        }
        
        @keyframes indicatorPulse {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.8; }
        }
        
        .controls {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
            margin: 40px 0;
            padding: 32px;
            background: rgba(255, 255, 255, 0.08);
            border-radius: 30px;
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            box-shadow: 
                0 15px 35px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            flex-wrap: wrap;
            position: relative;
            overflow: hidden;
        }
        
        .controls::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.05), transparent);
            transition: left 2s ease;
        }
        
        .controls:hover::before {
            left: 100%;
        }
        
        .controls-section {
            display: flex;
            gap: 12px;
            align-items: center;
        }
        
        .controls-divider {
            width: 1px;
            height: 40px;
            background: rgba(255, 255, 255, 0.2);
            margin: 0 8px;
        }
        
        .btn {
            padding: 18px 32px;
            border: none;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            min-width: 70px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 12px;
            position: relative;
            overflow: hidden;
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            font-family: inherit;
            text-decoration: none;
            box-shadow: 0 8px 25px rgba(0, 0, 0, 0.15);
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
            transition: left 0.6s ease;
        }
        
        .btn:hover::before {
            left: 100%;
        }
        
        .btn-round {
            width: 72px;
            height: 72px;
            border-radius: 50%;
            padding: 0;
            font-size: 28px;
            position: relative;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
        }
        
        .btn:hover {
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.25);
        }
        
        .btn:active {
            transform: translateY(-2px) scale(1.02);
        }
        
        .btn-call {
            background: linear-gradient(135deg, #4CAF50, #45a049, #66BB6A);
            color: white;
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.4);
        }
        
        .btn-call.active {
            background: linear-gradient(135deg, #f44336, #d32f2f, #e57373);
            box-shadow: 0 10px 30px rgba(244, 67, 54, 0.4);
            animation: pulseRed 2s infinite;
        }
        
        @keyframes pulseRed {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 10px 30px rgba(244, 67, 54, 0.4);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 15px 40px rgba(244, 67, 54, 0.6);
            }
        }
        
        .btn-audio {
            background: linear-gradient(135deg, #2196F3, #1976d2, #64B5F6);
            color: white;
            box-shadow: 0 10px 30px rgba(33, 150, 243, 0.4);
        }
        
        .btn-audio.muted {
            background: linear-gradient(135deg, #f44336, #d32f2f, #e57373);
            box-shadow: 0 10px 30px rgba(244, 67, 54, 0.4);
            animation: mutedPulse 2s infinite;
        }
        
        @keyframes mutedPulse {
            0%, 100% { 
                transform: scale(1);
                box-shadow: 0 0 20px rgba(244, 67, 54, 0.6);
            }
            50% { 
                transform: scale(1.05);
                box-shadow: 0 0 30px rgba(244, 67, 54, 0.8);
            }
        }
        
        .btn-video {
            background: linear-gradient(135deg, #FF9800, #f57c00, #FFB74D);
            color: white;
            box-shadow: 0 10px 30px rgba(255, 152, 0, 0.4);
        }
        
        .btn-video.muted {
            background: linear-gradient(135deg, #f44336, #d32f2f, #e57373);
            box-shadow: 0 10px 30px rgba(244, 67, 54, 0.4);
            animation: mutedPulse 2s infinite;
        }
        
        .btn-screen {
            background: linear-gradient(135deg, #673AB7, #512da8, #9575CD);
            color: white;
            box-shadow: 0 10px 30px rgba(103, 58, 183, 0.4);
        }
        
        .btn-screen.active {
            background: linear-gradient(135deg, #4CAF50, #45a049, #66BB6A);
            box-shadow: 0 10px 30px rgba(76, 175, 80, 0.4);
        }
        
        .btn-leave {
            background: linear-gradient(135deg, #f44336, #d32f2f, #e57373);
            color: white;
            box-shadow: 0 10px 30px rgba(244, 67, 54, 0.4);
        }
        
        .screen-sharing-controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            display: none;
        }
        
        .screen-sharing-controls h3 {
            margin: 0 0 15px 0;
            color: white;
            text-align: center;
        }
        
        .sharing-mode-tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            justify-content: center;
        }
        
        .sharing-tab {
            padding: 10px 20px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            background: rgba(255, 255, 255, 0.1);
            color: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 14px;
        }
        
        .sharing-tab.active {
            background: #673AB7;
            border-color: #673AB7;
        }
        
        .sharing-tab:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sharing-options {
            display: none;
            margin-top: 15px;
        }
        
        .sharing-options.active {
            display: block;
        }
        
        .sharing-option {
            padding: 12px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            margin-bottom: 10px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .sharing-option:hover {
            background: rgba(255, 255, 255, 0.2);
        }
        
        .sharing-option.selected {
            background: #673AB7;
            border-color: #673AB7;
        }
        
        .screen-preview {
            width: 100%;
            max-width: 300px;
            height: 200px;
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.3);
            margin: 10px auto;
            display: none;
        }
        
        .noise-controls {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 15px;
            padding: 20px;
            margin: 20px 0;
            backdrop-filter: blur(10px);
            max-height: 600px;
            overflow-y: auto;
        }
        
        .audio-tabs {
            display: flex;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .audio-tab {
            flex: 1;
            padding: 10px;
            background: transparent;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            transition: all 0.3s;
            font-size: 12px;
        }
        
        .audio-tab.active {
            background: #4CAF50;
            color: white;
        }
        
        .audio-tab:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .noise-controls h3 {
            margin: 0 0 15px 0;
            color: white;
            text-align: center;
        }
        
        .control-group {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin: 10px 0;
            padding: 8px 0;
        }
        
        .control-label {
            color: white;
            font-size: 14px;
            flex: 1;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 25px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 25px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .toggle-switch.active {
            background: #4CAF50;
        }
        
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 21px;
            height: 21px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .toggle-switch.active::after {
            transform: translateX(25px);
        }
        
        .slider-control {
            flex: 1;
            margin-left: 15px;
        }
        
        .audio-slider {
            width: 100%;
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }
        
        .audio-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
        }
        
        .audio-slider::-moz-range-thumb {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #4CAF50;
            cursor: pointer;
            border: none;
        }
        
        .btn-noise-profile {
            background: #9C27B0;
            color: white;
            padding: 8px 16px;
            font-size: 12px;
            border-radius: 20px;
        }
        
        .btn-noise-profile:hover {
            background: #7B1FA2;
        }
        
        .eq-container {
            display: flex;
            align-items: end;
            gap: 8px;
            height: 120px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
        }
        
        .eq-band {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }
        
        .eq-slider {
            writing-mode: bt-lr; /* IE */
            writing-mode: vertical-lr;
            width: 20px;
            height: 80px;
            -webkit-appearance: slider-vertical;
            appearance: slider-vertical;
            background: rgba(255, 255, 255, 0.3);
            outline: none;
        }
        
        .eq-label {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.8);
            text-align: center;
        }
        
        .audio-visualizer {
            width: 100%;
            height: 60px;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            margin: 10px 0;
            position: relative;
            overflow: hidden;
        }
        
        .visualizer-canvas {
            width: 100%;
            height: 100%;
            border-radius: 8px;
        }
        
        .preset-buttons {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin: 10px 0;
        }
        
        .preset-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.2);
            border: none;
            border-radius: 15px;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .preset-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }
        
        .preset-btn.active {
            background: #4CAF50;
        }
        
        .advanced-meter {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 6px;
            margin: 5px 0;
        }
        
        .meter-label {
            min-width: 60px;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .meter-bar {
            flex: 1;
            height: 6px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        
        .meter-fill {
            height: 100%;
            border-radius: 3px;
            transition: width 0.1s;
        }
        
        .meter-fill.volume { background: linear-gradient(90deg, #4CAF50, #8BC34A, #CDDC39); }
        .meter-fill.pitch { background: linear-gradient(90deg, #2196F3, #03A9F4, #00BCD4); }
        .meter-fill.clarity { background: linear-gradient(90deg, #9C27B0, #E91E63, #F44336); }
        
        .voice-effects {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin: 10px 0;
        }
        
        .effect-btn {
            padding: 12px 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            color: white;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }
        
        .effect-btn:hover {
            background: rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.4);
        }
        
        .effect-btn.active {
            background: #4CAF50;
            border-color: #4CAF50;
        }
        
        .noise-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin-top: 10px;
        }
        
        .noise-level-bar {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
        }
        
        .noise-level-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #FFEB3B, #f44336);
            width: 0%;
            transition: width 0.1s;
        }
        
        .quality-indicator {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .quality-status {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 12px;
        }
        
        .quality-level {
            display: flex;
            gap: 2px;
        }
        
        .quality-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transition: background 0.3s;
        }
        
        .quality-dot.active {
            background: #4CAF50;
        }
        
        .network-stats {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            display: flex;
            gap: 10px;
        }
        
        .quality-auto-toggle {
            position: relative;
            width: 40px;
            height: 20px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 20px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .quality-auto-toggle.active {
            background: #4CAF50;
        }
        
        .quality-auto-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 16px;
            height: 16px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .quality-auto-toggle.active::after {
            transform: translateX(20px);
        }
        
        .gcc-status {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 8px;
            margin: 8px 0;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .gcc-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            margin: 4px 0;
        }
        
        .gcc-signal {
            width: 12px;
            height: 12px;
            border-radius: 2px;
            transition: background 0.3s;
        }
        
        .gcc-signal.good { background: #4CAF50; }
        .gcc-signal.warning { background: #FF9800; }
        .gcc-signal.poor { background: #f44336; }
        
        .bitrate-bar {
            flex: 1;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            overflow: hidden;
            margin: 0 8px;
        }
        
        .bitrate-fill {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A, #CDDC39, #FF9800);
            transition: width 0.3s;
        }
        
        .gcc-controls {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }
        
        .gcc-toggle {
            position: relative;
            width: 35px;
            height: 18px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 18px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .gcc-toggle.active {
            background: #4CAF50;
        }
        
        .gcc-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .gcc-toggle.active::after {
            transform: translateX(17px);
        }
        
        .simulcast-status {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 8px;
            margin: 8px 0;
            font-size: 11px;
            color: rgba(255, 255, 255, 0.8);
        }
        
        .simulcast-layers {
            display: flex;
            gap: 4px;
            margin: 8px 0;
        }
        
        .layer-indicator {
            flex: 1;
            height: 20px;
            border-radius: 4px;
            background: rgba(255, 255, 255, 0.2);
            position: relative;
            transition: all 0.3s;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 9px;
            font-weight: bold;
        }
        
        .layer-indicator.active {
            background: #4CAF50;
            color: white;
        }
        
        .layer-indicator.sending {
            background: #2196F3;
            color: white;
        }
        
        .layer-indicator.receiving {
            background: #FF9800;
            color: white;
        }
        
        .layer-indicator.disabled {
            background: #f44336;
            color: white;
        }
        
        .layer-stats {
            font-size: 10px;
            color: rgba(255, 255, 255, 0.7);
            margin: 4px 0;
            display: flex;
            justify-content: space-between;
        }
        
        .svc-controls {
            display: flex;
            gap: 8px;
            margin: 8px 0;
            align-items: center;
        }
        
        .svc-toggle {
            position: relative;
            width: 35px;
            height: 18px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 18px;
            cursor: pointer;
            transition: background 0.3s;
        }
        
        .svc-toggle.active {
            background: #4CAF50;
        }
        
        .svc-toggle::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 14px;
            height: 14px;
            background: white;
            border-radius: 50%;
            transition: transform 0.3s;
        }
        
        .svc-toggle.active::after {
            transform: translateX(17px);
        }
        
        .layer-selector {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 4px;
            color: white;
            padding: 4px 8px;
            font-size: 10px;
            cursor: pointer;
        }
        
        .layer-selector:focus {
            outline: none;
            border-color: #4CAF50;
        }
        
        .bandwidth-distribution {
            display: flex;
            height: 12px;
            border-radius: 6px;
            overflow: hidden;
            margin: 4px 0;
            background: rgba(255, 255, 255, 0.1);
        }
        
        .bandwidth-segment {
            transition: width 0.3s;
        }
        
        .bandwidth-segment.low { background: #4CAF50; }
        .bandwidth-segment.medium { background: #FF9800; }
        .bandwidth-segment.high { background: #f44336; }
        
        .simulcast-metrics {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin: 8px 0;
            font-size: 10px;
        }
        
        .metric-item {
            display: flex;
            justify-content: space-between;
            padding: 2px 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
        }
        
    /* AI/ML UI removed */
        
    /* AI styles removed */
        
        /* Floating particles background effect */
        .floating-particles {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: -1;
        }
        
        .particle {
            position: absolute;
            width: 4px;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
            animation: float-up 15s infinite linear;
        }
        
        .particle:nth-child(odd) {
            background: rgba(102, 126, 234, 0.2);
            animation-duration: 20s;
        }
        
        .particle:nth-child(3n) {
            background: rgba(118, 75, 162, 0.2);
            animation-duration: 18s;
        }
        
        @keyframes float-up {
            0% {
                opacity: 0;
                transform: translateY(100vh) rotate(0deg);
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translateY(-100px) rotate(360deg);
            }
        }
        
        /* Enhanced status styles */
        .status {
            margin: 32px 0;
            padding: 20px 32px;
            border-radius: 20px;
            background: rgba(255, 255, 255, 0.08);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.12);
            text-align: center;
            font-weight: 600;
            font-size: 16px;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            box-shadow: 
                0 12px 30px rgba(0, 0, 0, 0.15),
                0 0 0 1px rgba(255, 255, 255, 0.05),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }
        
        .status.connected {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.25), rgba(76, 175, 80, 0.15));
            border-color: rgba(76, 175, 80, 0.4);
            color: #66BB6A;
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.2);
        }
        
        .status.disconnected {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.25), rgba(244, 67, 54, 0.15));
            border-color: rgba(244, 67, 54, 0.4);
            color: #ef5350;
            animation: statusPulse 2s infinite;
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.2);
        }
        
        @keyframes statusPulse {
            0%, 100% { 
                opacity: 1;
                transform: scale(1);
            }
            50% { 
                opacity: 0.8;
                transform: scale(1.02);
            }
        }
        
        /* Enhanced camera switch button */
        .btn-camera-switch {
            background: linear-gradient(135deg, #607D8B, #455A64, #78909C);
            color: white;
            box-shadow: 0 10px 30px rgba(96, 125, 139, 0.4);
        }
        
        .btn-camera-switch:hover {
            background: linear-gradient(135deg, #455A64, #37474F, #607D8B);
            transform: translateY(-4px) scale(1.05) rotate(180deg);
        }
        
        .btn-camera-switch.switching {
            background: linear-gradient(135deg, #4CAF50, #45a049, #66BB6A);
            animation: switchingPulse 1s infinite;
        }
        
        @keyframes switchingPulse {
            0% { transform: scale(1) rotate(0deg); }
            50% { transform: scale(1.1) rotate(180deg); }
            100% { transform: scale(1) rotate(360deg); }
        }
        
        /* Toast notification system */
        .toast-container {
            position: fixed;
            top: 24px;
            right: 24px;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            gap: 12px;
            pointer-events: none;
        }
        
        .toast {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(25px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            padding: 16px 24px;
            color: white;
            font-weight: 600;
            box-shadow: 0 15px 35px rgba(0, 0, 0, 0.2);
            transform: translateX(400px);
            opacity: 0;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            cursor: pointer;
            min-width: 300px;
            display: flex;
            align-items: center;
            gap: 12px;
        }
        
        .toast.show {
            transform: translateX(0);
            opacity: 1;
        }
        
        .toast.success {
            background: linear-gradient(135deg, rgba(76, 175, 80, 0.25), rgba(76, 175, 80, 0.15));
            border-color: rgba(76, 175, 80, 0.4);
            box-shadow: 0 0 30px rgba(76, 175, 80, 0.2);
        }
        
        .toast.error {
            background: linear-gradient(135deg, rgba(244, 67, 54, 0.25), rgba(244, 67, 54, 0.15));
            border-color: rgba(244, 67, 54, 0.4);
            box-shadow: 0 0 30px rgba(244, 67, 54, 0.2);
        }
        
        .toast.info {
            background: linear-gradient(135deg, rgba(33, 150, 243, 0.25), rgba(33, 150, 243, 0.15));
            border-color: rgba(33, 150, 243, 0.4);
            box-shadow: 0 0 30px rgba(33, 150, 243, 0.2);
        }
        
        .toast-icon {
            font-size: 20px;
            min-width: 24px;
        }
        
        .toast-close {
            margin-left: auto;
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.7);
            cursor: pointer;
            font-size: 18px;
            padding: 0;
            transition: color 0.3s ease;
        }
        
        .toast-close:hover {
            color: white;
        }
        
        /* Loading animation */
        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 25%, #16213e 50%, #0f3460 75%, #0a2545 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            opacity: 1;
            transition: opacity 0.5s ease;
        }
        
        .loading-overlay.hide {
            opacity: 0;
            pointer-events: none;
        }
        
        .loading-spinner {
            width: 80px;
            height: 80px;
            border: 4px solid rgba(255, 255, 255, 0.1);
            border-left: 4px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 24px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: white;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .audio-level {
            width: 100%;
            height: 12px;
            background: rgba(255, 255, 255, 0.15);
            border-radius: 6px;
            margin: 15px 0;
            overflow: hidden;
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .audio-level-bar {
            height: 100%;
            background: linear-gradient(90deg, #4CAF50, #8BC34A, #CDDC39, #FFEB3B, #FF9800, #f44336);
            width: 0%;
            transition: width 0.15s ease-out;
            border-radius: 6px;
            box-shadow: 0 0 10px rgba(76, 175, 80, 0.3);
        }
        
        .participants-info {
            background: rgba(255, 255, 255, 0.08);
            border-radius: 20px;
            padding: 24px;
            margin: 24px 0;
            backdrop-filter: blur(20px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }
        
        .participants-info:hover {
            transform: translateY(-2px);
            box-shadow: 0 15px 40px rgba(0, 0, 0, 0.15);
        }
        
        .no-video-placeholder {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100%;
            background: linear-gradient(135deg, #333, #555);
        }
        
        .no-video-placeholder .avatar {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 36px;
            margin-bottom: 10px;
        }
        
        @media (max-width: 768px) {
            body {
                padding: 16px;
            }
            
            .container {
                grid-template-columns: 1fr;
                gap: 20px;
                max-width: 100%;
                padding: 16px;
            }
            
            .container.chat-collapsed {
                grid-template-columns: 1fr;
            }
            
            .chat-sidebar {
                order: 2;
                height: auto;
                max-height: 350px;
                position: static;
                width: 100%;
                min-width: auto;
                border-radius: 24px;
                padding: 24px;
                /* Ensure chat is always visible on mobile unless explicitly collapsed */
                display: flex;
                opacity: 1;
                transform: none;
            }
            
            .chat-sidebar.collapsed {
                height: 80px;
                min-height: 80px;
                max-height: 80px;
                width: 100%;
                min-width: auto;
                border-radius: 20px;
                transform: none;
                /* Ensure collapsed state is stable on mobile */
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Improved chat toggle button for mobile */
            .chat-toggle-btn {
                position: absolute;
                top: 12px;
                right: 12px;
                width: 44px;
                height: 44px;
                font-size: 20px;
                z-index: 150;
                /* Make touch-friendly */
                touch-action: manipulation;
                -webkit-tap-highlight-color: rgba(255, 255, 255, 0.2);
            }
            
            /* Prevent chat content from disappearing unexpectedly on mobile */
            .chat-sidebar:not(.collapsed) .chat-content {
                display: flex;
                opacity: 1;
                transform: none;
                pointer-events: auto;
            }
            
            .main-content {
                order: 1;
            }
            
            .room-header {
                padding: 24px;
                border-radius: 24px;
            }
            
            .room-title {
                font-size: 28px;
            }
            
            .room-title::after {
                right: -30px;
                font-size: 20px;
            }
            
            .controls {
                flex-direction: column;
                gap: 16px;
                padding: 24px;
                border-radius: 24px;
            }
            
            .controls-section {
                justify-content: center;
                gap: 12px;
                flex-wrap: wrap;
            }
            
            .controls-divider {
                width: 80%;
                height: 1px;
                margin: 12px 0;
            }
            
            .btn {
                padding: 16px 28px;
                font-size: 15px;
            }
            
            .btn-round {
                width: 64px;
                height: 64px;
                font-size: 24px;
            }
            
            /* Hide screen sharing button on mobile by default */
            .btn-screen {
                display: none;
            }
            
            /* Show disabled screen sharing button with visual indication */
            .btn-screen.mobile-disabled {
                display: flex;
                opacity: 0.5;
                cursor: not-allowed;
            }
            
            .screen-sharing-controls {
                display: none !important;
            }
            
            .video-grid {
                gap: 16px;
                height: calc(100vh - 320px);
                padding: 12px;
                /* Enable smooth scrolling on mobile */
                overflow-y: auto;
                overflow-x: hidden;
                -webkit-overflow-scrolling: touch;
                /* Hide scrollbar on mobile for cleaner look */
                scrollbar-width: none;
                -ms-overflow-style: none;
            }
            
            .video-grid::-webkit-scrollbar {
                display: none;
            }
            
            /* Mobile specific grid layouts for better arrangement */
            .video-grid.participants-1 {
                grid-template-columns: 1fr;
                align-content: center;
            }
            
            .video-grid.participants-2,
            .video-grid.participants-3,
            .video-grid.participants-4 {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(auto-fit, minmax(180px, 1fr));
                align-content: start;
                height: auto;
                min-height: calc(100vh - 320px);
            }
            
            .video-grid.participants-5,
            .video-grid.participants-6,
            .video-grid.participants-7,
            .video-grid.participants-8,
            .video-grid.participants-9,
            .video-grid.participants-10,
            .video-grid.participants-11,
            .video-grid.participants-12,
            .video-grid.participants-13,
            .video-grid.participants-14,
            .video-grid.participants-15,
            .video-grid.participants-16,
            .video-grid.participants-more {
                grid-template-columns: repeat(2, 1fr);
                grid-template-rows: repeat(auto-fit, minmax(150px, 1fr));
                align-content: start;
                height: auto;
                min-height: calc(100vh - 320px);
                gap: 12px;
            }
            
            /* Override special 3-participant layout for mobile */
            .video-grid.participants-3 .video-container:nth-child(3) {
                grid-column: auto;
                max-width: 100%;
            }
            
            .video-container:hover {
                transform: translateY(-2px) scale(1.01);
                border-color: rgba(102, 126, 234, 0.6);
            }
            
            .chat-messages {
                max-height: 400px;
                min-height: 300px;
            }
            
            .chat-input-container {
                gap: 6px;
                padding: 8px;
                min-height: 56px;
                flex-wrap: nowrap;
                overflow: visible;
                width: 100%;
                box-sizing: border-box;
            }
            
            .chat-send-btn {
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                max-width: 44px !important;
                min-height: 44px !important;
                max-height: 44px !important;
                padding: 10px !important;
                font-size: 14px;
                flex-shrink: 0 !important;
                flex-grow: 0 !important;
                overflow: visible !important;
            }
            
            .file-upload-btn,
            .voice-record-btn {
                width: 44px !important;
                height: 44px !important;
                min-width: 44px !important;
                max-width: 44px !important;
                min-height: 44px !important;
                max-height: 44px !important;
                padding: 8px;
                flex-shrink: 0;
            }
            
            .chat-input {
                min-height: 40px;
                padding: 10px 16px;
                font-size: 14px;
            }
            
            .toast-container {
                top: 12px;
                right: 12px;
                left: 12px;
            }
            
            .toast {
                min-width: auto;
                width: 100%;
            }
        }
        
        @media (max-width: 480px) {
            .room-title {
                font-size: 24px;
            }
            
            .room-title::after {
                right: -25px;
                font-size: 18px;
            }
            
            .btn-round {
                width: 56px;
                height: 56px;
                font-size: 20px;
            }
            
            .controls-section {
                gap: 8px;
            }
            
            .video-grid {
                height: calc(100vh - 380px);
                gap: 12px;
                /* Ensure proper scrolling on very small screens */
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .video-grid.participants-5,
            .video-grid.participants-6,
            .video-grid.participants-7,
            .video-grid.participants-8,
            .video-grid.participants-9,
            .video-grid.participants-10,
            .video-grid.participants-11,
            .video-grid.participants-12,
            .video-grid.participants-13,
            .video-grid.participants-14,
            .video-grid.participants-15,
            .video-grid.participants-16,
            .video-grid.participants-more {
                grid-template-columns: 1fr;
                grid-template-rows: repeat(auto-fit, minmax(140px, 1fr));
                align-content: start;
                height: auto;
                min-height: calc(100vh - 380px);
            }
            
            /* Smaller video containers on very small screens */
            .video-container {
                min-width: 280px;
                min-height: 140px;
                border-radius: 16px;
            }
            
            .participant-serial {
                font-size: 10px !important;
                padding: 2px 6px !important;
            }
            
            .chat-sidebar {
                max-height: calc(100vh - 80px);
                min-height: 400px;
                padding: 20px;
                /* Disable 3D transforms on very small screens for stability */
                transform: none !important;
                transform-style: flat;
            }
            
            .chat-sidebar.collapsed {
                transform: none !important;
                /* Ensure collapsed state is clearly visible */
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* Improve chat input on very small screens */
            .chat-input-container {
                gap: 4px;
                padding: 6px;
                min-height: 52px;
            }
            
            .chat-input {
                min-height: 36px;
                padding: 8px 12px;
                font-size: 14px;
            }
            
            .chat-send-btn,
            .file-upload-btn,
            .voice-record-btn {
                width: 40px !important;
                height: 40px !important;
                min-width: 40px !important;
                max-width: 40px !important;
                min-height: 40px !important;
                max-height: 40px !important;
                padding: 6px;
                font-size: 12px;
            }
            
            .particle {
                display: none; /* Hide particles on very small screens */
            }
        }
    </style>
</head>
<body>
    <!-- Loading overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Initializing Video Conference...</div>
    </div>
    
    <!-- Floating particles background -->
    <div class="floating-particles" id="particles"></div>
    
    <!-- Toast notification container -->
    <div class="toast-container" id="toastContainer"></div>
    
    <div class="container">
        <div class="main-content">
            <div class="room-header">
                <h1 class="room-title">Video Conference Room</h1>
                <div class="room-id">
                    Room ID: <span class="room-id-value" onclick="copyRoomId()" title="Click to copy">{{ room_id }}</span>
                </div>
                <button class="btn" onclick="copyRoomId()" style="background: linear-gradient(135deg, #667eea, #764ba2, #f093fb); color: white; font-size: 15px; padding: 14px 28px; box-shadow: 0 8px 25px rgba(102, 126, 234, 0.3); transition: all 0.4s ease;">
                    ðŸ“‹ Copy Room ID
                </button>
                
                <!-- Layout Status Indicator -->
                <div class="layout-status" id="layoutStatus" style="margin-top: 16px; padding: 12px 20px; background: rgba(255, 255, 255, 0.1); border-radius: 20px; text-align: center; font-size: 14px; opacity: 0.9; transition: all 0.3s ease;">
                    <span id="layoutModeText">ðŸ’» Normal Layout Mode</span>
                    <span style="margin-left: 12px; font-size: 12px; opacity: 0.8;">Press 'C' to toggle chat â€¢ Double-click video to zoom</span>
                </div>
                
                <!-- Participant Count Indicator -->
                <div class="participant-info" id="participantInfo" style="margin-top: 12px; padding: 8px 16px; background: rgba(255, 255, 255, 0.08); border-radius: 16px; text-align: center; font-size: 12px; opacity: 0.8;">
                    <span id="participantCount">ðŸ‘¥ 0 Participants</span>
                    <span style="margin-left: 8px; opacity: 0.7;">Press 'C' to toggle chat</span>
                </div>
            </div>
            
            <div class="status" id="connectionStatus">
                Connecting to room...
            </div>
            
            <div class="controls">
                <div class="controls-section">
                    <button class="btn btn-round btn-call" id="callBtn" onclick="toggleCall()" title="Start/End Call">
                        <span id="callIcon">ðŸ“ž</span>
                    </button>
                    <button class="btn btn-round btn-audio" id="audioBtn" onclick="toggleAudio()" disabled title="Toggle Microphone">
                        <span id="audioIcon">ðŸŽ¤</span>
                    </button>
                    <button class="btn btn-round btn-video" id="videoBtn" onclick="toggleVideo()" disabled title="Toggle Camera">
                        <span id="videoIcon">ðŸ“¹</span>
                    </button>
                </div>
                
                <div class="controls-divider"></div>
                
                <div class="controls-section">
                    <button class="btn btn-round btn-camera-switch" id="cameraSwitchBtn" onclick="switchCamera()" disabled title="Switch Camera">
                        <span id="cameraSwitchIcon">ðŸ”„</span>
                    </button>
                    <button class="btn btn-round btn-screen" id="screenBtn" onclick="toggleScreenShare()" disabled title="Screen Share">
                        <span id="screenIcon">ðŸ–¥ï¸</span>
                    </button>
                </div>
                
                <div class="controls-divider"></div>
                
                <div class="controls-section">
                    <button class="btn btn-round" style="background: linear-gradient(135deg, #9C27B0, #7b1fa2);" onclick="toggleNoiseControls()" title="Audio Controls">
                        <span>ï¿½</span>
                    </button>
                    <button class="btn btn-round" style="background: linear-gradient(135deg, #673AB7, #512da8);" onclick="toggleScreenControls()" title="Screen Options">
                        <span>âš™ï¸</span>
                    </button>
                </div>
                
                <div class="controls-divider"></div>
                
                <div class="controls-section">
                    <button class="btn btn-leave" onclick="leaveRoom()" title="Leave Room">
                        ðŸšª Leave Room
                    </button>
                </div>
            </div>
            
            <!-- AI controls removed -->
            
            <div class="noise-controls" id="noiseControls" style="display: none;">
                <h3>ðŸŽ›ï¸ Advanced Audio Processing</h3>
                
                <div class="audio-tabs">
                    <button class="audio-tab active" onclick="switchAudioTab('basic')">Basic</button>
                    <button class="audio-tab" onclick="switchAudioTab('equalizer')">EQ</button>
                    <button class="audio-tab" onclick="switchAudioTab('effects')">Effects</button>
                    <button class="audio-tab" onclick="switchAudioTab('analysis')">Analysis</button>
                </div>
                
                <!-- Basic Controls Tab -->
                <div class="tab-content active" id="basicTab">
                    <div class="control-group">
                        <label class="control-label">Enhanced Noise Reduction</label>
                        <div class="toggle-switch" id="enhancedNoiseToggle" onclick="toggleEnhancedNoise()"></div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">High-Pass Filter (Remove Low Rumble)</label>
                        <div class="toggle-switch" id="highPassToggle" onclick="toggleHighPassFilter()"></div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Dynamic Compression</label>
                        <div class="toggle-switch" id="compressionToggle" onclick="toggleCompression()"></div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Voice Isolation</label>
                        <div class="toggle-switch" id="voiceIsolationToggle" onclick="toggleVoiceIsolation()"></div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Noise Gate Threshold</label>
                        <div class="slider-control">
                            <input type="range" class="audio-slider" id="noiseGateSlider" min="0" max="100" value="20" oninput="updateNoiseGate(this.value)">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Master Gain</label>
                        <div class="slider-control">
                            <input type="range" class="audio-slider" id="gainSlider" min="0.1" max="3.0" step="0.1" value="1.0" oninput="updateGain(this.value)">
                        </div>
                    </div>
                    
                    <div class="control-group">
                        <button class="btn btn-noise-profile" onclick="captureNoiseProfile()">
                            ðŸ“Š Capture Noise Profile
                        </button>
                        <button class="btn btn-noise-profile" onclick="resetAudioSettings()" style="background: #f44336;">
                            ðŸ”„ Reset All
                        </button>
                    </div>
                </div>
                
                <!-- Equalizer Tab -->
                <div class="tab-content" id="equalizerTab">
                    <div class="preset-buttons">
                        <button class="preset-btn active" onclick="applyEQPreset('flat')">Flat</button>
                        <button class="preset-btn" onclick="applyEQPreset('vocal')">Vocal</button>
                        <button class="preset-btn" onclick="applyEQPreset('broadcast')">Broadcast</button>
                        <button class="preset-btn" onclick="applyEQPreset('bass-cut')">Bass Cut</button>
                        <button class="preset-btn" onclick="applyEQPreset('presence')">Presence</button>
                    </div>
                    
                    <div class="eq-container">
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq60" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('60', this.value)">
                            <div class="eq-label">60Hz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq170" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('170', this.value)">
                            <div class="eq-label">170Hz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq310" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('310', this.value)">
                            <div class="eq-label">310Hz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq600" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('600', this.value)">
                            <div class="eq-label">600Hz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq1000" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('1000', this.value)">
                            <div class="eq-label">1kHz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq3000" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('3000', this.value)">
                            <div class="eq-label">3kHz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq6000" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('6000', this.value)">
                            <div class="eq-label">6kHz</div>
                        </div>
                        <div class="eq-band">
                            <input type="range" class="eq-slider" id="eq12000" min="-12" max="12" value="0" step="0.5" oninput="updateEQ('12000', this.value)">
                            <div class="eq-label">12kHz</div>
                        </div>
                    </div>
                </div>
                
                <!-- Effects Tab -->
                <div class="tab-content" id="effectsTab">
                    <div class="voice-effects">
                        <button class="effect-btn" id="reverbBtn" onclick="toggleEffect('reverb')">
                            ðŸ›ï¸<br>Reverb
                        </button>
                        <button class="effect-btn" id="echoBtn" onclick="toggleEffect('echo')">
                            ðŸ“¢<br>Echo
                        </button>
                        <button class="effect-btn" id="robotBtn" onclick="toggleEffect('robot')">
                            ðŸ¤–<br>Robot
                        </button>
                        <button class="effect-btn" id="pitchUpBtn" onclick="toggleEffect('pitchUp')">
                            â¬†ï¸<br>Pitch Up
                        </button>
                        <button class="effect-btn" id="pitchDownBtn" onclick="toggleEffect('pitchDown')">
                            â¬‡ï¸<br>Pitch Down
                        </button>
                        <button class="effect-btn" id="chorusBtn" onclick="toggleEffect('chorus')">
                            ðŸŽµ<br>Chorus
                        </button>
                    </div>
                    
                    <div class="control-group">
                        <label class="control-label">Effect Intensity</label>
                        <div class="slider-control">
                            <input type="range" class="audio-slider" id="effectIntensity" min="0" max="100" value="50" oninput="updateEffectIntensity(this.value)">
                        </div>
                    </div>
                </div>
                
                <!-- Analysis Tab -->
                <div class="tab-content" id="analysisTab">
                    <div class="audio-visualizer">
                        <canvas class="visualizer-canvas" id="audioVisualizer"></canvas>
                    </div>
                    
                    <div class="advanced-meter">
                        <div class="meter-label">Volume</div>
                        <div class="meter-bar">
                            <div class="meter-fill volume" id="volumeMeter"></div>
                        </div>
                        <span id="volumeText">0%</span>
                    </div>
                    
                    <div class="advanced-meter">
                        <div class="meter-label">Pitch</div>
                        <div class="meter-bar">
                            <div class="meter-fill pitch" id="pitchMeter"></div>
                        </div>
                        <span id="pitchText">0Hz</span>
                    </div>
                    
                    <div class="advanced-meter">
                        <div class="meter-label">Clarity</div>
                        <div class="meter-bar">
                            <div class="meter-fill clarity" id="clarityMeter"></div>
                        </div>
                        <span id="clarityText">0%</span>
                    </div>
                    
                    <div class="noise-indicator">
                        <span style="font-size: 12px; color: white;">Background Noise:</span>
                        <div class="noise-level-bar">
                            <div class="noise-level-fill" id="noiseLevelFill"></div>
                        </div>
                        <span id="noiseLevelText" style="font-size: 12px; color: white;">0%</span>
                    </div>
                    
                    <div class="quality-indicator">
                        <div class="quality-status">
                            <span>ðŸ“¡ Video Quality:</span>
                            <div class="quality-level" id="qualityLevel">
                                <div class="quality-dot" id="quality0"></div>
                                <div class="quality-dot" id="quality1"></div>
                                <div class="quality-dot active" id="quality2"></div>
                                <div class="quality-dot" id="quality3"></div>
                                <div class="quality-dot" id="quality4"></div>
                            </div>
                            <span id="qualityText">Medium</span>
                        </div>
                        <div class="quality-auto-toggle active" id="adaptiveQualityToggle" onclick="toggleAdaptiveQuality()" title="Toggle Adaptive Quality"></div>
                    </div>
                    
                    <div class="network-stats" id="networkStats">
                        <span>RTT: <span id="rttValue">-</span>ms</span>
                        <span>Loss: <span id="lossValue">-</span>%</span>
                        <span>Jitter: <span id="jitterValue">-</span>ms</span>
                    </div>
                    
                    <div class="gcc-status" id="gccStatus">
                        <div class="gcc-indicator">
                            <div class="gcc-signal good" id="gccSignal"></div>
                            <span>GCC Status:</span>
                            <span id="gccState">Normal</span>
                        </div>
                        
                        <div class="gcc-indicator">
                            <span style="min-width: 55px;">Bitrate:</span>
                            <div class="bitrate-bar">
                                <div class="bitrate-fill" id="bitrateFill"></div>
                            </div>
                            <span id="bitrateValue">500</span>kbps
                        </div>
                        
                        <div class="gcc-indicator">
                            <span style="min-width: 55px;">Target:</span>
                            <span id="targetBitrateValue">500</span>kbps
                            <span style="margin-left: auto;">BW Est:</span>
                            <span id="bandwidthEstimate">-</span>kbps
                        </div>
                        
                        <div class="gcc-controls">
                            <span style="font-size: 10px; margin-right: 8px;">GCC:</span>
                            <div class="gcc-toggle active" id="gccToggle" onclick="toggleGCC()" title="Toggle Google Congestion Control"></div>
                        </div>
                    </div>
                    
                    <div class="simulcast-status" id="simulcastStatus">
                        <div class="gcc-indicator">
                            <span>ðŸ“¡ Simulcast Layers:</span>
                        </div>
                        
                        <div class="simulcast-layers" id="simulcastLayers">
                            <div class="layer-indicator active" id="layer-low" onclick="toggleLayer('low')" title="Low Quality Layer">
                                LOW<br>320p
                            </div>
                            <div class="layer-indicator active" id="layer-medium" onclick="toggleLayer('medium')" title="Medium Quality Layer">
                                MED<br>480p
                            </div>
                            <div class="layer-indicator active" id="layer-high" onclick="toggleLayer('high')" title="High Quality Layer">
                                HIGH<br>720p
                            </div>
                        </div>
                        
                        <div class="bandwidth-distribution" id="bandwidthDistribution">
                            <div class="bandwidth-segment low" id="bw-low" style="width: 33.3%"></div>
                            <div class="bandwidth-segment medium" id="bw-medium" style="width: 33.3%"></div>
                            <div class="bandwidth-segment high" id="bw-high" style="width: 33.4%"></div>
                        </div>
                        
                        <div class="layer-stats">
                            <span>Active: <span id="activeLayers">3</span>/3</span>
                            <span>Switches: <span id="layerSwitches">0</span></span>
                            <span>Bandwidth: <span id="totalBandwidth">2.15</span>Mbps</span>
                        </div>
                        
                        <div class="svc-controls">
                            <span style="font-size: 10px;">Simulcast:</span>
                            <div class="svc-toggle active" id="simulcastToggle" onclick="toggleSimulcast()" title="Toggle Simulcast"></div>
                            
                            <span style="font-size: 10px; margin-left: 8px;">SVC:</span>
                            <div class="svc-toggle active" id="svcToggle" onclick="toggleSVC()" title="Toggle Scalable Video Coding"></div>
                            
                            <span style="font-size: 10px; margin-left: 8px;">Seamless:</span>
                            <div class="svc-toggle active" id="seamlessToggle" onclick="toggleSeamlessSwitching()" title="Toggle Seamless Layer Switching"></div>
                            
                            <select class="layer-selector" id="layerSelector" onchange="selectPreferredLayer(this.value)" title="Preferred Receive Layer">
                                <option value="auto">Auto</option>
                                <option value="low">Low</option>
                                <option value="medium">Medium</option>
                                <option value="high">High</option>
                            </select>
                        </div>
                        
                        <div class="simulcast-metrics" id="simulcastMetrics">
                            <div class="metric-item">
                                <span>Low FPS:</span>
                                <span id="lowFps">0</span>
                            </div>
                            <div class="metric-item">
                                <span>Med FPS:</span>
                                <span id="mediumFps">0</span>
                            </div>
                            <div class="metric-item">
                                <span>High FPS:</span>
                                <span id="highFps">0</span>
                            </div>
                            <div class="metric-item">
                                <span>Quality:</span>
                                <span id="currentQuality">Auto</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Screen Sharing Controls -->
            <div class="screen-sharing-controls" id="screenControls" style="display: none;">
                <h3>ðŸ–¥ï¸ Screen Sharing Options</h3>
                
                <!-- Mobile Warning -->
                <div id="mobileWarning" style="display: none; background: rgba(255, 152, 0, 0.2); border: 1px solid #FF9800; border-radius: 8px; padding: 15px; margin-bottom: 15px; text-align: center;">
                    <strong>ðŸ“± Mobile Device Detected</strong><br>
                    Screen sharing is not supported on mobile browsers. Please use a desktop browser (Chrome, Firefox, Safari, or Edge) for screen sharing functionality.
                </div>
                
                <div class="sharing-mode-tabs">
                    <div class="sharing-tab active" data-mode="screen" onclick="switchSharingMode('screen')">
                        Screen Sharing
                    </div>
                </div>
                
                <div class="sharing-options active" id="screenOptions">
                    <div class="sharing-option" onclick="shareEntireScreen()">
                        ðŸ–¥ï¸ Share Entire Screen
                    </div>
                </div>
                
                <video class="screen-preview" id="screenPreview" autoplay muted playsinline></video>
                
                <div class="control-group" style="margin-top: 15px;">
                    <button class="btn" onclick="startScreenShare()" id="startShareBtn" style="background: #4CAF50;">
                        â–¶ï¸ Start Sharing
                    </button>
                    <button class="btn" onclick="stopScreenShare()" id="stopShareBtn" style="background: #f44336; display: none;">
                        â¹ï¸ Stop Sharing
                    </button>
                </div>
            </div>
            
            <div class="audio-level">
                <div class="audio-level-bar" id="audioLevelBar"></div>
            </div>
            
            <div class="video-grid" id="videoGrid">
                <!-- Local video will be added here -->
                <!-- Remote videos will be added here dynamically -->
            </div>
            
            <div class="participants-info">
                <h3 style="margin-bottom: 12px; color: #667eea; font-weight: 600;">
                    ðŸ‘¥ Participants (<span id="chatParticipantCount">0</span>)
                </h3>
                <div class="audio-level">
                    <div class="audio-level-bar" id="audioLevelBar"></div>
                </div>
                <p style="font-size: 12px; opacity: 0.8; margin: 8px 0 0 0;">Your microphone level</p>
            </div>
        </div>
        
        <div class="chat-sidebar" id="chatSidebar">
            <!-- Always visible toggle button with double-click support -->
            <button class="chat-toggle-btn" id="chatToggleBtn" onclick="toggleChat()" ondblclick="doubleTapChat()" title="Minimize Chat | Double-click for full video mode">
                â—€ï¸
            </button>
            
            <div class="chat-content">
                <!-- Foreground Chat Icon -->
                <div class="chat-foreground-icon" title="Chat Room Active">
                    ðŸ’¬
                </div>
                
                <div class="chat-header">
                    <div class="chat-header-content">
                        <h3>ðŸ’¬ Chat Room</h3>
                        <p style="font-size: 12px; opacity: 0.8; margin: 0;">Real-time messaging</p>
                    </div>
                </div>
            
            <div class="chat-messages" id="chatMessages">
                <div class="message system">
                    <div class="message-content">Welcome to the video call! Start chatting below.</div>
                </div>
            </div>
            
            <div class="typing-indicator" id="typingIndicator"></div>
            
            <div class="chat-input-container">
                <input type="file" class="file-input" id="fileInput" accept=".txt,.pdf,.png,.jpg,.jpeg,.gif,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.zip,.rar,.7z,.mp3,.mp4,.avi,.mov,.wav" multiple>
                <button class="file-upload-btn" id="fileUploadBtn" onclick="triggerFileUpload()" title="Share files">
                    ðŸ“Ž
                </button>
                <button class="voice-record-btn" id="voiceRecordBtn" onclick="toggleVoiceRecording()" title="Record voice message">
                    ðŸŽ¤
                </button>
                <input type="text" class="chat-input" id="chatInput" placeholder="Type your message..." maxlength="500">
                <button class="chat-send-btn" id="chatSendBtn" onclick="sendMessage()">
                    <span>ðŸ“¤</span>
                </button>
            </div>
            </div> <!-- Close chat-content -->
        </div>
    </div>

    <!-- Upload progress indicator -->
    <div class="upload-progress hidden" id="uploadProgress">
        <div>Uploading file...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
        <div id="progressText">0%</div>
    </div>

    <!-- Voice recording indicator -->
    <div class="recording-indicator hidden" id="recordingIndicator">
        <div class="recording-wave">
            <div class="recording-bar"></div>
            <div class="recording-bar"></div>
            <div class="recording-bar"></div>
            <div class="recording-bar"></div>
            <div class="recording-bar"></div>
        </div>
        <div class="recording-time" id="recordingTime">00:00</div>
        <div class="recording-controls">
            <button class="recording-control-btn stop" onclick="stopVoiceRecording()">Stop & Send</button>
            <button class="recording-control-btn cancel" onclick="cancelVoiceRecording()">Cancel</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/socket.io/4.7.2/socket.io.js"></script>
    <script>
        // Floating particles animation
        function createFloatingParticles() {
            const particleContainer = document.getElementById('particles');
            
            function createParticle() {
                const particle = document.createElement('div');
                particle.className = 'particle';
                
                // Random horizontal position
                particle.style.left = Math.random() * 100 + '%';
                
                // Random size between 2px and 6px
                const size = Math.random() * 4 + 2;
                particle.style.width = size + 'px';
                particle.style.height = size + 'px';
                
                // Random animation duration
                const duration = Math.random() * 10 + 15;
                particle.style.animationDuration = duration + 's';
                
                // Random delay
                particle.style.animationDelay = Math.random() * 5 + 's';
                
                particleContainer.appendChild(particle);
                
                // Remove particle after animation
                setTimeout(() => {
                    if (particle.parentNode) {
                        particle.parentNode.removeChild(particle);
                    }
                }, duration * 1000);
            }
            
            // Create initial particles
            for (let i = 0; i < 15; i++) {
                setTimeout(createParticle, i * 500);
            }
            
            // Continuously create new particles
            setInterval(createParticle, 2000);
        }
        
        // Enhanced UI interactions
        function addEnhancedInteractions() {
            // Add hover effects to buttons
            document.querySelectorAll('.btn').forEach(btn => {
                btn.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-6px) scale(1.05)';
                    this.style.boxShadow = '0 20px 40px rgba(0, 0, 0, 0.25)';
                });
                
                btn.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0) scale(1)';
                    this.style.boxShadow = '';
                });
            });
            
            // Add ripple effect to video containers
            document.querySelectorAll('.video-container').forEach(container => {
                container.addEventListener('click', function(e) {
                    const ripple = document.createElement('div');
                    ripple.style.cssText = `
                        position: absolute;
                        border-radius: 50%;
                        background: rgba(255, 255, 255, 0.3);
                        pointer-events: none;
                        transform: scale(0);
                        animation: ripple 0.6s linear;
                        width: 100px;
                        height: 100px;
                        left: ${e.offsetX - 50}px;
                        top: ${e.offsetY - 50}px;
                    `;
                    
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes ripple {
                            to {
                                transform: scale(4);
                                opacity: 0;
                            }
                        }
                    `;
                    document.head.appendChild(style);
                    
                    this.appendChild(ripple);
                    setTimeout(() => {
                        ripple.remove();
                        style.remove();
                    }, 600);
                });
            });
        }
        
        // Initialize enhanced features
        document.addEventListener('DOMContentLoaded', function() {
            createFloatingParticles();
            addEnhancedInteractions();
            
            // Initialize participant count display
            updateParticipantCount();
            
            // Hide loading overlay after a short delay
            setTimeout(() => {
                const loadingOverlay = document.getElementById('loadingOverlay');
                if (loadingOverlay) {
                    loadingOverlay.classList.add('hide');
                    setTimeout(() => {
                        loadingOverlay.style.display = 'none';
                    }, 500);
                }
            }, 1500);
        });
        
        // Toast notification system
        function showToast(message, type = 'info', duration = 4000) {
            const toastContainer = document.getElementById('toastContainer');
            const toast = document.createElement('div');
            toast.className = `toast ${type}`;
            
            const icons = {
                success: 'âœ…',
                error: 'âŒ',
                info: 'â„¹ï¸',
                warning: 'âš ï¸'
            };
            
            toast.innerHTML = `
                <span class="toast-icon">${icons[type] || icons.info}</span>
                <span class="toast-message">${message}</span>
                <button class="toast-close" onclick="removeToast(this.parentElement)">Ã—</button>
            `;
            
            toastContainer.appendChild(toast);
            
            // Trigger animation
            setTimeout(() => toast.classList.add('show'), 10);
            
            // Auto remove
            setTimeout(() => removeToast(toast), duration);
            
            return toast;
        }
        
        function removeToast(toast) {
            if (toast && toast.parentElement) {
                toast.classList.remove('show');
                setTimeout(() => {
                    if (toast.parentElement) {
                        toast.parentElement.removeChild(toast);
                    }
                }, 400);
            }
        }
        
        const roomId = '{{ room_id }}';
        const socket = io();
        
        // WebRTC configuration
        const configuration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };
        
        let localStream = null;
        let isCallActive = false;
        let isAudioMuted = false;
        let isVideoMuted = false;
        let isVideoEnabled = false;
        let peerConnections = {};
        let participants = new Map();
        let forceMutedUsers = new Set(); // Track users that are force-muted locally
        let bannedUsers = new Set(); // Track users that are banned from the room
        let audioContext = null;
        let analyser = null;
        let dataArray = null;
        let typingTimer = null;
        let isTyping = false;
        let username = `User ${Math.random().toString(36).substring(2, 8).toUpperCase()}`;
        
        // Voice recording variables
        let isRecordingVoice = false;
        let voiceMediaRecorder = null;
        let voiceAudioChunks = [];
        let voiceRecordingStream = null;
        let voiceRecordingStartTime = null;
        let voiceRecordingTimer = null;
        let currentPlayingVoice = null;
        
        // Advanced Audio Processing Variables
        let processedStream = null;
        let audioProcessingContext = null;
        let sourceNode = null;
        let destinationNode = null;
        let gainNode = null;
        let highPassFilter = null;
        let compressorNode = null;
        let noiseGateNode = null;
        let enhancedNoiseReduction = false;
        let highPassFilterEnabled = false;
        let compressionEnabled = false;
        let voiceIsolationEnabled = false;
        let noiseGateThreshold = 0.2;
        let currentGain = 1.0;
        let noiseProfile = null;
        let noiseAnalyser = null;
        let noiseDataArray = null;
        
        // Equalizer and Effects
        let eqFilters = {};
        let activeEffects = new Set();
        let effectIntensity = 0.5;
        let reverbNode = null;
        let delayNode = null;
        let chorusNodes = [];
        let pitchShiftNode = null;
        
        // Analysis
        let visualizerCanvas = null;
        let visualizerContext = null;
        let animationFrame = null;
        let frequencyAnalyser = null;
        let frequencyDataArray = null;
        let pitchDetector = null;
        
        // Screen Sharing Variables
        let isScreenSharing = false;
        let screenStream = null;
        let screenControls = null;
        let screenBtn = null;
        let screenIcon = null;
        let screenPreview = null;
        
        // Mobile Detection
        let isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        let isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
        let isAndroid = /Android/.test(navigator.userAgent);
        
        // Camera Switching Variables
        let currentFacingMode = 'user'; // 'user' for front camera, 'environment' for back camera
        let availableCameras = [];
        let currentCameraDeviceId = null;
        let cameraSwitchBtn = null;
        let cameraSwitchIcon = null;
        let isSwitchingCamera = false;
        
        // Video Focus/Zoom Variables
        let focusedVideoUserId = null;
        let videoFocusEnabled = true;
        
        // Adaptive Bitrate and Resolution Scaling Variables
        let adaptiveQualityEnabled = true;
        let currentQualityLevel = 2; // 0=lowest, 4=highest
        let qualityLevels = [
            { width: 320, height: 240, frameRate: 15, bitrate: 150000 },   // Very Low
            { width: 480, height: 360, frameRate: 20, bitrate: 300000 },   // Low
            { width: 640, height: 480, frameRate: 25, bitrate: 500000 },   // Medium (default)
            { width: 960, height: 720, frameRate: 30, bitrate: 1000000 },  // High
            { width: 1280, height: 720, frameRate: 30, bitrate: 1500000 }  // Very High
        ];
        let networkStats = {
            packetsLost: 0,
            jitter: 0,
            rtt: 0,
            bandwidth: 0,
            timestamp: Date.now(),
            sendTimeMs: 0,
            receiveTimeMs: 0,
            totalBytes: 0,
            totalPackets: 0
        };
        let statsInterval = null;
        let qualityAdjustmentTimer = null;
        let lastQualityAdjustment = 0;
        let consecutiveBadNetworkSamples = 0;
        let consecutiveGoodNetworkSamples = 0;
        let adaptiveQualitySettings = {
            adjustmentCooldown: 5000, // 5 seconds minimum between adjustments
            badNetworkThreshold: 3,   // Consecutive bad samples before downgrade
            goodNetworkThreshold: 5,  // Consecutive good samples before upgrade
            packetLossThreshold: 0.02, // 2% packet loss triggers downgrade
            rttThreshold: 300,        // 300ms RTT triggers downgrade
            jitterThreshold: 50       // 50ms jitter triggers downgrade
        };
        
        // Google Congestion Control (GCC) Variables
        let gccEnabled = true;
        let gccController = {
            currentBitrate: 500000,        // Current sending bitrate (bps)
            targetBitrate: 500000,         // Target bitrate based on network conditions
            maxBitrate: 2000000,           // Maximum allowed bitrate
            minBitrate: 100000,            // Minimum allowed bitrate
            
            // Delay-based controller
            delayBasedController: {
                threshold: 12.5,           // Delay variation threshold (ms)
                slope: 0.8,                // Filter coefficient
                offset: 0,                 // Filter offset
                prevOffset: 0,             // Previous offset
                hypothesis: 'normal',      // 'increase', 'decrease', 'normal'
                lastUpdateTime: 0,
                delayHistory: [],
                maxHistorySize: 20
            },
            
            // Loss-based controller
            lossBasedController: {
                lossRate: 0,
                lossThreshold: 0.02,       // 2% loss threshold
                decreaseFactor: 0.85,      // Multiplicative decrease
                increaseFactor: 1.05,      // Additive increase
                lastUpdateTime: 0
            },
            
            // Rate controller
            rateController: {
                increaseRate: 1000,        // Bits per second to increase when network is good
                decreaseRate: 0.85,        // Factor to decrease when network is bad
                minIncrease: 1000,         // Minimum increase in bps
                maxIncrease: 30000,        // Maximum increase in bps
                lastUpdateTime: 0
            },
            
            // Bandwidth estimator
            bandwidthEstimator: {
                estimatedBandwidth: 0,
                confidence: 0,
                probeCluster: null,
                probingState: 'inactive',  // 'inactive', 'probing', 'waiting'
                probeHistory: [],
                smoothedRtt: 0,
                rttVariance: 0
            }
        };
        
        // Simulcast and SVC Variables
        let simulcastEnabled = true;
        let svcEnabled = true;
        let simulcastLayers = [
            { 
                rid: 'low', 
                width: 320, 
                height: 240, 
                frameRate: 15, 
                bitrate: 150000,
                scalabilityMode: 'L1T2'  // 1 spatial, 2 temporal layers
            },
            { 
                rid: 'medium', 
                width: 640, 
                height: 480, 
                frameRate: 25, 
                bitrate: 500000,
                scalabilityMode: 'L1T3'  // 1 spatial, 3 temporal layers
            },
            { 
                rid: 'high', 
                width: 1280, 
                height: 720, 
                frameRate: 30, 
                bitrate: 1500000,
                scalabilityMode: 'L1T3'  // 1 spatial, 3 temporal layers
            }
        ];
        let currentSimulcastLayers = new Map(); // Track active layers per peer
        let layerSwitchHistory = new Map(); // Track layer switching decisions
        let simulcastStats = {
            activeLayers: new Set(),
            totalBytesSent: 0,
            layerBytesSent: {},
            lastLayerSwitch: 0,
            switchCount: 0
        };
        let receiverPreferences = new Map(); // Track preferred layers per receiver
        
        // Seamless Switching Variables
        let seamlessSwitching = true;
        let layerTransitionBuffers = new Map(); // Buffer frames during transitions
        let currentReceiveLayers = new Map(); // Track current receive layer per peer
        let layerSwitchCooldown = new Map(); // Prevent rapid switching
        let frameBuffers = new Map(); // Frame buffering for smooth transitions
        let transitionStates = new Map(); // Track transition progress
        let layerSwitchDelay = 100; // Minimum delay between switches (ms)
        let bufferFrameCount = 3; // Number of frames to buffer for smooth transition
        
    // AI/ML variables removed
        
        // Get username from server template or URL parameters
        const serverUsername = '{{ username }}';
        if (serverUsername && serverUsername.trim() && serverUsername !== '') {
            username = serverUsername.trim().substring(0, 20);
            console.log('Username set from server:', username);
        } else {
            // Fallback to URL parameters
            const urlParams = new URLSearchParams(window.location.search);
            const urlUsername = urlParams.get('username');
            if (urlUsername && urlUsername.trim()) {
                username = urlUsername.trim().substring(0, 20);
                console.log('Username set from URL parameter:', username);
            } else {
                console.log('No username provided, using random:', username);
            }
        }
        
        // DOM elements
        const callBtn = document.getElementById('callBtn');
        const audioBtn = document.getElementById('audioBtn');
        const videoBtn = document.getElementById('videoBtn');
        const callIcon = document.getElementById('callIcon');
        const audioIcon = document.getElementById('audioIcon');
        const videoIcon = document.getElementById('videoIcon');
        const connectionStatus = document.getElementById('connectionStatus');
        const participantCount = document.getElementById('participantCount');
        const audioLevelBar = document.getElementById('audioLevelBar');
        const videoGrid = document.getElementById('videoGrid');
        const chatMessages = document.getElementById('chatMessages');
        const chatInput = document.getElementById('chatInput');
        const chatSendBtn = document.getElementById('chatSendBtn');
        const typingIndicator = document.getElementById('typingIndicator');
        
        // Noise Control Elements
        const noiseControls = document.getElementById('noiseControls');
        const enhancedNoiseToggle = document.getElementById('enhancedNoiseToggle');
        const highPassToggle = document.getElementById('highPassToggle');
        const compressionToggle = document.getElementById('compressionToggle');
        const voiceIsolationToggle = document.getElementById('voiceIsolationToggle');
        const noiseGateSlider = document.getElementById('noiseGateSlider');
        const gainSlider = document.getElementById('gainSlider');
        const noiseLevelFill = document.getElementById('noiseLevelFill');
        const noiseLevelText = document.getElementById('noiseLevelText');
        
        // Analysis Elements
        const volumeMeter = document.getElementById('volumeMeter');
        const pitchMeter = document.getElementById('pitchMeter');
        const clarityMeter = document.getElementById('clarityMeter');
        const volumeText = document.getElementById('volumeText');
        const pitchText = document.getElementById('pitchText');
        const clarityText = document.getElementById('clarityText');
        const effectIntensitySlider = document.getElementById('effectIntensity');
        
        // Screen Sharing Elements
        screenControls = document.getElementById('screenControls');
        screenBtn = document.getElementById('screenBtn');
        screenIcon = document.getElementById('screenIcon');
        screenPreview = document.getElementById('screenPreview');
        const startShareBtn = document.getElementById('startShareBtn');
        const stopShareBtn = document.getElementById('stopShareBtn');
        
        // Camera Switch Elements
        cameraSwitchBtn = document.getElementById('cameraSwitchBtn');
        cameraSwitchIcon = document.getElementById('cameraSwitchIcon');
        
    // AI elements removed
        
        // Socket event handlers
        socket.on('connect', () => {
            console.log('Connected to server');
            updateConnectionStatus('Connected to server', 'connected');
            socket.emit('join_room', { 
                room_id: roomId,
                username: username
            });
        });
        
        socket.on('disconnect', () => {
            console.log('Disconnected from server');
            updateConnectionStatus('Disconnected from server', 'disconnected');
        });
        
        socket.on('existing_users', (data) => {
            console.log('Existing users:', data.users);
            data.users.forEach(userInfo => {
                const userId = userInfo.user_id || userInfo;
                const mediaState = userInfo.media_state || {};
                const userUsername = userInfo.username || `User ${userId.substring(0, 6).toUpperCase()}`;
                participants.set(userId, { 
                    username: userUsername,
                    mediaState 
                });
                
                // If we're already in a call, create peer connection immediately
                if (isCallActive && localStream) {
                    console.log('Creating peer connection for existing user:', userId);
                    createPeerConnection(userId, true);
                }
            });
            updateParticipantCount();
        });
        
        socket.on('user_joined', (data) => {
            console.log('User joined:', data.user_id, 'Username:', data.username);
            
            // Check if user is banned
            if (preventBannedUserJoin(data.user_id)) {
                showNotification(`Banned user ${data.username} attempted to join`, 'warning');
                return;
            }
            
            participants.set(data.user_id, { 
                username: data.username,
                mediaState: data.media_state || {}
            });
            updateParticipantCount();
            
            // If we're already in a call, immediately create peer connection
            if (isCallActive && localStream) {
                console.log('Creating peer connection for newly joined user:', data.user_id);
                createPeerConnection(data.user_id, true);
            }
        });
        
        socket.on('user_left', (data) => {
            console.log('User left:', data.user_id);
            participants.delete(data.user_id);
            updateParticipantCount();
            
            if (peerConnections[data.user_id]) {
                peerConnections[data.user_id].close();
                delete peerConnections[data.user_id];
            }
            
            // Clean up force mute state
            if (forceMutedUsers.has(data.user_id)) {
                forceMutedUsers.delete(data.user_id);
                console.log(`Removed force mute state for user ${data.user_id}`);
            }
            
            // Remove video element
            removeVideoElement(data.user_id);
        });
        
        socket.on('media_state_changed', (data) => {
            console.log('Media state changed:', data);
            if (participants.has(data.user_id)) {
                const userInfo = participants.get(data.user_id);
                userInfo.mediaState = data.media_state;
                participants.set(data.user_id, userInfo);
                updateVideoOverlay(data.user_id);
            }
        });
        
        socket.on('user_audio_toggled', (data) => {
            console.log('User audio toggled:', data);
            if (participants.has(data.user_id)) {
                const userInfo = participants.get(data.user_id);
                userInfo.mediaState.audio_muted = data.muted;
                participants.set(data.user_id, userInfo);
                updateVideoOverlay(data.user_id);
            }
        });
        
        socket.on('user_video_toggled', (data) => {
            console.log('User video toggled:', data);
            if (participants.has(data.user_id)) {
                const userInfo = participants.get(data.user_id);
                userInfo.mediaState.video_muted = data.muted;
                participants.set(data.user_id, userInfo);
                updateVideoOverlay(data.user_id);
            }
        });
        
        socket.on('offer', async (data) => {
            console.log('Received offer from:', data.sender);
            await handleOffer(data.offer, data.sender);
        });
        
        socket.on('answer', async (data) => {
            console.log('Received answer from:', data.sender);
            await handleAnswer(data.answer, data.sender);
        });
        
        socket.on('ice_candidate', async (data) => {
            console.log('Received ICE candidate from:', data.sender);
            await handleIceCandidate(data.candidate, data.sender);
        });
        
        // Chat event handlers
        socket.on('chat_history', (data) => {
            console.log('Received chat history:', data.messages.length, 'messages');
            data.messages.forEach(message => {
                displayMessage(message);
            });
        });
        
        socket.on('new_message', (data) => {
            console.log('New message:', data);
            displayMessage(data);
        });
        
        socket.on('user_typing', (data) => {
            console.log('User typing:', data);
            updateTypingIndicator(data);
        });
        
        // Ban-related socket events
        socket.on('user_banned', (data) => {
            console.log('User banned notification:', data);
            const displayName = data.banned_username || `User ${data.banned_user_id.substring(0, 6).toUpperCase()}`;
            showNotification(`${displayName} has been banned from the room`, 'warning');
            
            // Add to local banned list
            bannedUsers.add(data.banned_user_id);
            
            // Remove from participants if present
            if (participants.has(data.banned_user_id)) {
                participants.delete(data.banned_user_id);
                updateParticipantCount();
            }
            
            // Close peer connection if exists
            if (peerConnections[data.banned_user_id]) {
                peerConnections[data.banned_user_id].close();
                delete peerConnections[data.banned_user_id];
            }
            
            // Remove video element
            removeVideoElement(data.banned_user_id);
        });
        
        socket.on('banned_user_rejected', (data) => {
            console.log('Banned user was rejected:', data);
            const displayName = data.username || `User ${data.user_id.substring(0, 6).toUpperCase()}`;
            showNotification(`Banned user ${displayName} was prevented from joining`, 'info');
        });
        
        socket.on('you_are_banned', (data) => {
            alert('You have been banned from this room and cannot rejoin with this ID.');
            // Redirect to home page or show error
            window.location.href = '/';
        });
        
    // AI socket events removed
        
        // WebRTC functions
        function initializeWebGLEffects() {
            try {
                console.log('Initializing WebGL effects...');
                
                // Check if classes are available
                if (typeof WebGLVideoEffects === 'undefined') {
                    throw new Error('WebGLVideoEffects class not loaded');
                }
                if (typeof ARMaskGenerator === 'undefined') {
                    throw new Error('ARMaskGenerator class not loaded');
                }
                
                webglEffects = new WebGLVideoEffects();
                arMaskGenerator = new ARMaskGenerator();
                
                // Create effects canvas
                effectsCanvas = document.createElement('canvas');
                effectsCanvas.width = 640;
                effectsCanvas.height = 480;
                
                // Load AR masks
                loadARMasks();
                
                // Initialize performance monitoring
                webglPerformanceMonitor = setInterval(updateWebGLPerformance, 1000);
                
                updateWebGLStatus('WebGL Ready', true);
                console.log('WebGL video effects initialized successfully');
                
                return true;
                
            } catch (error) {
                console.error('Failed to initialize WebGL effects:', error);
                updateWebGLStatus('WebGL Error', false);
            }
        }
        
        async function loadARMasks() {
            if (!arMaskGenerator) return;
            
            try {
                const masks = arMaskGenerator.generateAllMasks();
                
                for (const [name, dataUrl] of Object.entries(masks)) {
                    await webglEffects.loadMaskTexture(name, dataUrl);
                }
                
                console.log('AR masks loaded successfully');
            } catch (error) {
                console.error('Failed to load AR masks:', error);
            }
        }
        
        function toggleVideoEffects() {
            const effectsControls = document.getElementById('videoEffectsControls');
            if (effectsControls.style.display === 'none') {
                effectsControls.style.display = 'block';
                if (!webglEffects && !videoEffectsEnabled) {
                    initializeWebGLEffects();
                }
            } else {
                effectsControls.style.display = 'none';
            }
        }
        
        function switchEffectsTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.effects-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('#videoEffectsControls .tab-content').forEach(content => content.classList.remove('active'));
            
            // Add active class to selected tab and content
            event.target.classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
        }
        
        async function setVideoEffect(effectName) {
            if (!webglEffects) {
                console.warn('WebGL effects not initialized');
                return;
            }
            
            console.log('ðŸŽ­ Setting video effect:', effectName);
            currentVideoEffect = effectName;
            
            // Update UI
            document.querySelectorAll('.effect-button').forEach(btn => btn.classList.remove('active'));
            document.querySelector(`[data-effect="${effectName}"]`).classList.add('active');
            
            // Apply effect to WebGL engine
            if (effectName === 'none') {
                console.log('ðŸ”„ Disabling video effects...');
                webglEffects.setEffect('none');
                videoEffectsEnabled = false;
                
                // Stop effects stream
                if (effectsStream) {
                    console.log('ðŸ›‘ Stopping effects stream...');
                    effectsStream.getTracks().forEach(track => track.stop());
                    effectsStream = null;
                }
                
                // Restore original stream
                if (localStream) {
                    console.log('âœ… Restoring original video stream');
                    await replaceVideoTrack(localStream);
                } else {
                    console.error('âŒ No local stream to restore');
                }
            } else if (effectName === 'background-blur') {
                console.log('ï¿½ï¸ Enabling background blur...');
                videoEffectsEnabled = true;
                webglEffects.setEffect('background-blur');
                
                // Set default blur intensity
                webglEffects.setBlurIntensity(0.8);
                
                // Process video stream with small delay to ensure WebGL is ready
                if (localStream) {
                    console.log('ðŸ”„ Processing video with background blur...');
                    await new Promise(resolve => setTimeout(resolve, 100));
                    await processVideoWithEffects();
                } else {
                    console.error('âŒ No local stream to process');
                }
            }
            
            document.getElementById('currentEffectText').textContent = effectName;
            console.log('âœ… Video effect set to:', effectName);
        }
        
        // Function to ensure canvas stream is active and valid
        function ensureCanvasStreamActive() {
            if (!effectsCanvas || !effectsStream) {
                console.warn('Canvas or stream not available');
                return false;
            }
            
            const tracks = effectsStream.getVideoTracks();
            if (tracks.length === 0) {
                console.warn('No video tracks in effects stream');
                return false;
            }
            
            const track = tracks[0];
            if (track.readyState !== 'live') {
                console.warn('Effects stream track is not live:', track.readyState);
                return false;
            }
            
            // Check if canvas has content
            const hasContent = debugCanvasContent();
            if (!hasContent) {
                console.warn('Canvas has no content, drawing fallback');
                const ctx = effectsCanvas.getContext('2d');
                ctx.fillStyle = '#0066cc';
                ctx.fillRect(0, 0, effectsCanvas.width, effectsCanvas.height);
                ctx.fillStyle = 'white';
                ctx.font = '48px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('Video Processing...', effectsCanvas.width / 2, effectsCanvas.height / 2);
                return false;
            }
            
            return true;
        }
        
        function setBlurIntensity(value) {
            if (webglEffects) {
                webglEffects.setBlurIntensity(parseFloat(value));
            }
        }
        
        function toggleWebGLEffects() {
            if (!webglEffects) {
                initializeWebGLEffects();
                document.getElementById('webglToggleText').textContent = 'Disable WebGL';
            } else {
                if (videoEffectsEnabled) {
                    setVideoEffect('none');
                }
                webglEffects.destroy();
                webglEffects = null;
                videoEffectsEnabled = false;
                document.getElementById('webglToggleText').textContent = 'Enable WebGL';
                updateWebGLStatus('Disabled', false);
            }
        }
        
        async function processVideoWithEffects() {
            if (!webglEffects || !localStream) return;
            
            try {
                const videoTrack = localStream.getVideoTracks()[0];
                if (!videoTrack) return;
                
                // Create video element for processing
                const videoElement = document.createElement('video');
                videoElement.srcObject = new MediaStream([videoTrack]);
                videoElement.autoplay = true;
                videoElement.muted = true;
                
                await new Promise(resolve => {
                    videoElement.onloadedmetadata = resolve;
                    setTimeout(resolve, 1000); // Fallback timeout
                });
                
                // Ensure canvas is properly sized
                effectsCanvas.width = videoElement.videoWidth || 640;
                effectsCanvas.height = videoElement.videoHeight || 480;
                
                console.log('Canvas sized to:', effectsCanvas.width, 'x', effectsCanvas.height);
                
                // Wait for video to be ready and process multiple frames to ensure canvas has content
                if (webglEffects && videoElement.readyState >= 2) {
                    // Process several frames to ensure stable content
                    for (let i = 0; i < 3; i++) {
                        await webglEffects.processVideoFrame(videoElement, effectsCanvas);
                        await new Promise(resolve => setTimeout(resolve, 33)); // Wait ~1 frame
                    }
                    
                    // Verify canvas has content
                    const hasContent = debugCanvasContent();
                    if (!hasContent) {
                        console.warn('Canvas still empty after processing, drawing fallback content');
                        const ctx = effectsCanvas.getContext('2d');
                        ctx.drawImage(videoElement, 0, 0, effectsCanvas.width, effectsCanvas.height);
                    }
                }
                
                // Create effects stream AFTER ensuring canvas has content
                if (!effectsStream) {
                    effectsStream = effectsCanvas.captureStream(30);
                    console.log('Created effects stream from canvas');
                    
                    // Replace video track in peer connections
                    await replaceVideoTrack(effectsStream);
                }
                
                // Start processing loop
                const processFrame = async () => {
                    if (videoEffectsEnabled && webglEffects && videoElement.readyState >= 2) {
                        try {
                            await webglEffects.processVideoFrame(videoElement, effectsCanvas);
                            
                            // Debug canvas content every 60 frames (about 2 seconds at 30fps)
                            if (Math.random() < 0.02) {
                                debugCanvasContent();
                            }
                        } catch (error) {
                            console.error('Frame processing error:', error);
                        }
                    }
                    
                    if (videoEffectsEnabled) {
                        requestAnimationFrame(processFrame);
                    }
                };
                
                processFrame();
                console.log('Video effects processing started');
                
            } catch (error) {
                console.error('Video processing error:', error);
            }
        }
        
        async function replaceVideoTrack(stream) {
            const videoTrack = stream.getVideoTracks()[0];
            if (!videoTrack) {
                console.error('No video track found in stream');
                return;
            }
            
            console.log('Replacing video track, stream has', stream.getVideoTracks().length, 'video tracks');
            console.log('New track settings:', videoTrack.getSettings());
            console.log('New track state:', videoTrack.readyState, 'enabled:', videoTrack.enabled);
            
            // Ensure the track is enabled and ready
            videoTrack.enabled = true;
            
            // Replace video track in all peer connections
            const replacePromises = [];
            for (const [userId, pc] of Object.entries(peerConnections)) {
                const sender = pc.getSenders().find(s => 
                    s.track && s.track.kind === 'video'
                );
                
                if (sender) {
                    const replacePromise = sender.replaceTrack(videoTrack).then(() => {
                        console.log(`âœ… Video track replaced for user ${userId}`);
                    }).catch(error => {
                        console.error(`âŒ Failed to replace video track for user ${userId}:`, error);
                        // Try to re-add the track if replacement fails
                        return pc.addTrack(videoTrack, stream).then(() => {
                            console.log(`âœ… Video track re-added for user ${userId}`);
                        });
                    });
                    replacePromises.push(replacePromise);
                } else {
                    console.warn(`No video sender found for user ${userId}, trying to add track...`);
                    try {
                        pc.addTrack(videoTrack, stream);
                        console.log(`âœ… Video track added for user ${userId}`);
                    } catch (error) {
                        console.error(`âŒ Failed to add video track for user ${userId}:`, error);
                    }
                }
            }
            
            // Wait for all replacements to complete
            await Promise.allSettled(replacePromises);
            
            // Update local video display
            const localVideo = document.querySelector('#localVideo');
            if (localVideo) {
                localVideo.srcObject = stream;
                console.log('âœ… Local video display updated');
                
                // Ensure local video plays
                try {
                    await localVideo.play();
                } catch (e) {
                    console.warn('Local video play failed:', e);
                }
            } else {
                console.warn('Local video element not found');
            }
            
            console.log('ðŸŽ¥ Video track replacement completed');
        }
        
        function updateWebGLPerformance() {
            if (webglEffects) {
                const fps = webglEffects.getFPS();
                document.getElementById('webglFps').textContent = fps;
                
                const performanceInfo = webglEffects.getPerformanceInfo();
                document.getElementById('currentEffectText').textContent = performanceInfo.currentEffect;
                
                // Update status dot color based on performance
                const statusDot = document.getElementById('webglStatusDot');
                if (fps >= 25) {
                    statusDot.className = 'status-dot';
                } else if (fps >= 15) {
                    statusDot.className = 'status-dot warning';
                } else {
                    statusDot.className = 'status-dot error';
                }
            }
        }
        
        function updateWebGLStatus(status, isWorking) {
            document.getElementById('webglStatusText').textContent = status;
            const statusDot = document.getElementById('webglStatusDot');
            statusDot.className = isWorking ? 'status-dot' : 'status-dot error';
        }
        
        // Debug function to check canvas content
        function debugCanvasContent() {
            if (effectsCanvas) {
                const ctx = effectsCanvas.getContext('2d');
                const imageData = ctx.getImageData(0, 0, effectsCanvas.width, effectsCanvas.height);
                const data = imageData.data;
                
                // Check if canvas has any non-black pixels
                let hasContent = false;
                for (let i = 0; i < data.length; i += 4) {
                    if (data[i] > 0 || data[i + 1] > 0 || data[i + 2] > 0) {
                        hasContent = true;
                        break;
                    }
                }
                
                console.log('Canvas has content:', hasContent);
                console.log('Canvas size:', effectsCanvas.width, 'x', effectsCanvas.height);
                
                return hasContent;
            }
            return false;
        }
        
        // Test function to verify stream replacement
        async function testStreamReplacement() {
            console.log('=== Stream Replacement Test ===');
            console.log('Local stream tracks:', localStream ? localStream.getTracks().length : 'No local stream');
            console.log('Effects stream tracks:', effectsStream ? effectsStream.getTracks().length : 'No effects stream');
            console.log('Peer connections:', Object.keys(peerConnections).length);
            
            // Test canvas content
            const hasContent = debugCanvasContent();
            
            if (!hasContent && effectsCanvas) {
                console.log('Canvas is black, drawing test pattern...');
                const ctx = effectsCanvas.getContext('2d');
                
                // Draw a test pattern
                ctx.fillStyle = 'red';
                ctx.fillRect(0, 0, effectsCanvas.width / 2, effectsCanvas.height / 2);
                ctx.fillStyle = 'green';
                ctx.fillRect(effectsCanvas.width / 2, 0, effectsCanvas.width / 2, effectsCanvas.height / 2);
                ctx.fillStyle = 'blue';
                ctx.fillRect(0, effectsCanvas.height / 2, effectsCanvas.width / 2, effectsCanvas.height / 2);
                ctx.fillStyle = 'yellow';
                ctx.fillRect(effectsCanvas.width / 2, effectsCanvas.height / 2, effectsCanvas.width / 2, effectsCanvas.height / 2);
                
                // Create new stream from test pattern
                const testStream = effectsCanvas.captureStream(30);
                await replaceVideoTrack(testStream);
                
                console.log('Test pattern applied to canvas and stream replaced');
            }
        }
        
        // Force refresh video stream for debugging
        async function forceRefreshStream() {
            console.log('=== Force Refresh Stream ===');
            
            if (effectsStream) {
                console.log('Stopping effects stream...');
                effectsStream.getTracks().forEach(track => track.stop());
                effectsStream = null;
            }
            
            if (currentEffect !== 'none' || currentMask !== 'none') {
                console.log('Re-enabling effects after refresh...');
                await processVideoWithEffects();
            } else {
                console.log('Restoring original stream...');
                await replaceVideoTrack(localStream);
            }
        }
        
        // Check video stream stats for debugging
        async function checkVideoStreamStats() {
            console.log('=== Video Stream Stats ===');
            
            // Check local streams
            if (localStream) {
                const videoTracks = localStream.getVideoTracks();
                console.log('Local stream video tracks:', videoTracks.length);
                videoTracks.forEach((track, index) => {
                    console.log(`Track ${index}:`, {
                        id: track.id,
                        kind: track.kind,
                        enabled: track.enabled,
                        readyState: track.readyState,
                        settings: track.getSettings()
                    });
                });
            }
            
            // Check effects stream
            if (effectsStream) {
                const videoTracks = effectsStream.getVideoTracks();
                console.log('Effects stream video tracks:', videoTracks.length);
                videoTracks.forEach((track, index) => {
                    console.log(`Effects track ${index}:`, {
                        id: track.id,
                        kind: track.kind,
                        enabled: track.enabled,
                        readyState: track.readyState,
                        settings: track.getSettings()
                    });
                });
            }
            
            // Check peer connection senders
            for (const [userId, pc] of Object.entries(peerConnections)) {
                console.log(`Peer ${userId} senders:`);
                const senders = pc.getSenders();
                senders.forEach((sender, index) => {
                    if (sender.track) {
                        console.log(`Sender ${index}:`, {
                            kind: sender.track.kind,
                            id: sender.track.id,
                            enabled: sender.track.enabled,
                            readyState: sender.track.readyState
                        });
                    }
                });
            }
        }
        
        // WebRTC functions
        async function startCall() {
            try {
                console.log('Starting call - requesting media access...');
                
                // Get initial quality constraints based on current quality level
                const quality = qualityLevels[currentQualityLevel];
                const constraints = {
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }, 
                    video: {
                        width: { ideal: quality.width, max: simulcastLayers[2].width },
                        height: { ideal: quality.height, max: simulcastLayers[2].height },
                        frameRate: { ideal: quality.frameRate, max: 30 }
                    }
                };
                
                // Request both audio and video with adaptive quality
                localStream = await navigator.mediaDevices.getUserMedia(constraints);
                
                console.log('Got local stream with tracks:', localStream.getTracks().map(t => t.kind));
                
                // Apply advanced audio processing
                await setupAdvancedAudioProcessing(localStream);
                
                isCallActive = true;
                isVideoEnabled = true;
                
                // Update UI
                callBtn.classList.add('active');
                callIcon.textContent = 'ðŸ“µ';
                audioBtn.disabled = false;
                videoBtn.disabled = false;
                
                // Enable screen sharing only on desktop browsers
                if (!isMobile && navigator.mediaDevices && navigator.mediaDevices.getDisplayMedia) {
                    screenBtn.disabled = false;
                } else {
                    screenBtn.disabled = true;
                    screenBtn.title = isMobile ? "Screen sharing not supported on mobile devices" : "Screen sharing not supported in this browser";
                    screenBtn.style.opacity = "0.5";
                }
                
                // Show noise controls
                noiseControls.style.display = 'block';
                
                // Create local video element
                createLocalVideoElement();
                
                // Setup audio level monitoring
                setupAudioLevelMonitoring();
                
                // Start adaptive quality monitoring with simulcast
                startAdaptiveQualityMonitoring();
                
                // Initialize simulcast if enabled
                if (simulcastEnabled) {
                    initializeSimulcast();
                }
                
                // Update media state on server
                updateServerMediaState();
                
                // Enumerate available cameras for camera switching
                await enumerateCameras();
                
                // Create peer connections for existing users AND add tracks
                console.log('Creating peer connections for existing users:', Array.from(participants.keys()));
                for (const [userId, userInfo] of participants) {
                    await createPeerConnection(userId, true);
                }
                
                updateConnectionStatus('Call active - Video/Audio connected', 'connected');
                
            } catch (error) {
                console.error('Error accessing video devices:', error);
                // Fallback to audio only if video fails
                try {
                    console.log('Falling back to audio-only...');
                    localStream = await navigator.mediaDevices.getUserMedia({ 
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: true
                        }
                    });
                    
                    console.log('Got audio-only stream');
                    
                    // Apply advanced audio processing for audio-only mode
                    await setupAdvancedAudioProcessing(localStream);
                    
                    isCallActive = true;
                    isVideoEnabled = false;
                    
                    callBtn.classList.add('active');
                    callIcon.textContent = 'ðŸ“µ';
                    audioBtn.disabled = false;
                    videoBtn.disabled = false;
                    videoBtn.classList.add('muted');
                    videoIcon.textContent = 'ðŸ“¹';
                    
                    // Show noise controls
                    noiseControls.style.display = 'block';
                    
                    createLocalVideoElement();
                    setupAudioLevelMonitoring();
                    updateServerMediaState();
                    
                    for (const [userId, userInfo] of participants) {
                        await createPeerConnection(userId, true);
                    }
                    
                    updateConnectionStatus('Call active - Audio only (camera unavailable)', 'connected');
                    
                } catch (audioError) {
                    console.error('Error accessing audio:', audioError);
                    alert('Could not access microphone or camera. Please check permissions.');
                    updateConnectionStatus('Media access denied', 'disconnected');
                }
            }
        }
        
        function endCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }
            
            // Clean up advanced audio processing
            cleanupAudioProcessing();
            
            // Stop adaptive quality monitoring
            stopAdaptiveQualityMonitoring();
            
            // Clean up simulcast
            cleanupSimulcast();
            
            // Stop screen sharing if active
            if (isScreenSharing) {
                stopScreenShare();
            }
            
            // Close all peer connections
            Object.values(peerConnections).forEach(pc => pc.close());
            peerConnections = {};
            
            // Remove all video elements
            videoGrid.innerHTML = '';
            
            isCallActive = false;
            isAudioMuted = false;
            isVideoMuted = false;
            isVideoEnabled = false;
            
            // Reset UI
            callBtn.classList.remove('active');
            callIcon.textContent = 'ðŸ“ž';
            audioBtn.disabled = true;
            videoBtn.disabled = true;
            screenBtn.disabled = true;
            cameraSwitchBtn.disabled = true;
            audioBtn.classList.remove('muted');
            videoBtn.classList.remove('muted');
            screenBtn.classList.remove('active');
            cameraSwitchBtn.classList.remove('switching');
            audioIcon.textContent = 'ðŸŽ¤';
            videoIcon.textContent = 'ðŸ“¹';
            screenIcon.textContent = 'ðŸ–¥ï¸';
            cameraSwitchIcon.textContent = 'ðŸ”„';
            cameraSwitchBtn.style.opacity = '0.5';
            cameraSwitchBtn.title = 'Start call to switch cameras';
            
            // Hide noise controls
            noiseControls.style.display = 'none';
            
            // Hide screen controls
            screenControls.style.display = 'none';
            
            // Update server
            updateServerMediaState();
            
            // Stop audio monitoring
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            updateConnectionStatus('Call ended', 'disconnected');
        }
        
        async function createPeerConnection(userId, isInitiator) {
            const peerConnection = new RTCPeerConnection(configuration);
            peerConnections[userId] = peerConnection;
            
            // Add local stream to peer connection if available
            if (processedStream || localStream) {
                const streamToUse = processedStream || localStream;
                
                // Add audio track normally
                const audioTrack = streamToUse.getAudioTracks()[0];
                if (audioTrack) {
                    peerConnection.addTrack(audioTrack, streamToUse);
                }
                
                // Add video track with simulcast if enabled
                const videoTrack = streamToUse.getVideoTracks()[0];
                if (videoTrack) {
                    const sender = peerConnection.addTrack(videoTrack, streamToUse);
                    
                    // Configure simulcast encoding parameters
                    if (simulcastEnabled && sender.setParameters) {
                        await configureSimulcastEncodings(sender, userId);
                    } else if (adaptiveQualityEnabled) {
                        // Fallback to single layer with bitrate constraints
                        applyBitrateConstraints(sender, currentQualityLevel);
                    }
                }
            }
            
            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log(`Received ${event.track.kind} track from:`, userId);
                const remoteStream = event.streams[0];
                
                // Handle simulcast layers for incoming stream
                if (event.track.kind === 'video' && simulcastEnabled) {
                    handleIncomingSimulcastStream(userId, event, remoteStream);
                } else {
                    // Update or create remote video element
                    updateRemoteVideoElement(userId, remoteStream);
                }
            };
            
            // Handle connection state changes
            peerConnection.onconnectionstatechange = () => {
                console.log(`Connection state for ${userId}:`, peerConnection.connectionState);
                
                // Start collecting stats for this peer connection
                if (peerConnection.connectionState === 'connected') {
                    startStatsCollection(userId, peerConnection);
                }
            };
            
            // Handle ICE gathering state changes
            peerConnection.onicegatheringstatechange = () => {
                console.log(`ICE gathering state for ${userId}:`, peerConnection.iceGatheringState);
            };
            
            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log(`Sending ICE candidate to ${userId}`);
                    socket.emit('ice_candidate', {
                        target: userId,
                        candidate: event.candidate
                    });
                }
            };
            
            // Create offer if initiator
            if (isInitiator) {
                try {
                    console.log(`Creating offer for user ${userId}`);
                    const offer = await peerConnection.createOffer({
                        offerToReceiveAudio: true,
                        offerToReceiveVideo: true
                    });
                    await peerConnection.setLocalDescription(offer);
                    
                    socket.emit('offer', {
                        target: userId,
                        offer: offer
                    });
                } catch (error) {
                    console.error('Error creating offer:', error);
                }
            }
        }
        
        async function handleOffer(offer, senderId) {
            try {
                console.log(`Handling offer from ${senderId}`);
                
                if (!peerConnections[senderId]) {
                    createPeerConnection(senderId, false);
                }
                
                const peerConnection = peerConnections[senderId];
                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));
                
                // Create answer
                const answer = await peerConnection.createAnswer({
                    offerToReceiveAudio: true,
                    offerToReceiveVideo: true
                });
                await peerConnection.setLocalDescription(answer);
                
                console.log(`Sending answer to ${senderId}`);
                socket.emit('answer', {
                    target: senderId,
                    answer: answer
                });
            } catch (error) {
                console.error('Error handling offer:', error);
            }
        }
        
        async function handleAnswer(answer, senderId) {
            try {
                console.log(`Handling answer from ${senderId}`);
                const peerConnection = peerConnections[senderId];
                if (peerConnection) {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                }
            } catch (error) {
                console.error('Error handling answer:', error);
            }
        }
        
        async function handleIceCandidate(candidate, senderId) {
            try {
                console.log(`Handling ICE candidate from ${senderId}`);
                const peerConnection = peerConnections[senderId];
                if (peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                }
            } catch (error) {
                console.error('Error handling ICE candidate:', error);
            }
        }
        
        function createLocalVideoElement() {
            // Remove existing local video
            const existingLocal = document.getElementById('local-video-container');
            if (existingLocal) {
                existingLocal.remove();
            }
            
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container local';
            videoContainer.id = 'local-video-container';
            
            if (localStream && isVideoEnabled && !isVideoMuted) {
                const videoElement = document.createElement('video');
                videoElement.id = 'local-video';
                videoElement.srcObject = localStream;
                videoElement.autoplay = true;
                videoElement.muted = true; // Local video is always muted to prevent feedback
                videoElement.playsInline = true;
                videoContainer.appendChild(videoElement);
            } else {
                // Show placeholder when video is disabled
                const placeholder = document.createElement('div');
                placeholder.className = 'no-video-placeholder';
                placeholder.innerHTML = `
                    <div class="avatar">ðŸ‘¤</div>
                    <div>You</div>
                `;
                videoContainer.appendChild(placeholder);
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'video-overlay';
            overlay.innerHTML = `
                <div class="user-name">You (${username})</div>
                <div class="media-indicators">
                    <div class="media-indicator audio-indicator ${isAudioMuted ? 'muted' : 'active'}" title="Audio">
                        ${isAudioMuted ? 'ðŸ”‡' : 'ðŸŽ¤'}
                    </div>
                    <div class="media-indicator video-indicator ${!isVideoEnabled || isVideoMuted ? 'muted' : 'active'}" title="Video">
                        ${!isVideoEnabled || isVideoMuted ? 'ðŸ“¹' : 'ðŸ“º'}
                    </div>
                </div>
            `;
            
            videoContainer.appendChild(overlay);
            videoGrid.insertBefore(videoContainer, videoGrid.firstChild);
            
            // Auto-adjust grid layout after adding local video
            adjustVideoGridLayout();
        }
        
        function createRemoteVideoElement(userId, stream) {
            console.log(`Creating video element for user ${userId}`);
            
            // Remove existing video element if any
            removeVideoElement(userId);
            
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';
            videoContainer.id = `video-container-${userId}`;
            
            // Check if stream has video track
            const videoTracks = stream.getVideoTracks();
            const hasVideo = videoTracks.length > 0 && videoTracks[0].enabled;
            
            console.log(`User ${userId} has video: ${hasVideo}, video tracks: ${videoTracks.length}`);
            
            if (hasVideo) {
                const videoElement = document.createElement('video');
                videoElement.id = `video-${userId}`;
                videoElement.srcObject = stream;
                videoElement.autoplay = true;
                videoElement.playsInline = true;
                videoElement.muted = false; // Remote video should not be muted
                
                // Handle video load events
                videoElement.onloadedmetadata = () => {
                    console.log(`Video metadata loaded for user ${userId}`);
                    videoElement.play().catch(e => console.error('Error playing video:', e));
                };
                
                videoContainer.appendChild(videoElement);
            } else {
                // Show placeholder when video is disabled
                const placeholder = document.createElement('div');
                placeholder.className = 'no-video-placeholder';
                placeholder.innerHTML = `
                    <div class="avatar">ðŸ‘¤</div>
                    <div>User ${userId.substring(0, 6)}</div>
                `;
                videoContainer.appendChild(placeholder);
            }
            
            const overlay = document.createElement('div');
            overlay.className = 'video-overlay';
            overlay.id = `overlay-${userId}`;
            
            videoContainer.appendChild(overlay);
            videoGrid.appendChild(videoContainer);
            
            // Auto-adjust grid layout after adding remote video
            adjustVideoGridLayout();
            
            // Update overlay with current media state
            updateVideoOverlay(userId);
            
            // Attach video focus click handler
            attachVideoFocusHandler(userId);
            
            // Also handle audio from the stream
            const audioTracks = stream.getAudioTracks();
            if (audioTracks.length > 0) {
                console.log(`User ${userId} has ${audioTracks.length} audio track(s)`);
                
                // Create hidden audio element for audio playback
                let audioElement = document.getElementById(`audio-${userId}`);
                if (!audioElement) {
                    audioElement = document.createElement('audio');
                    audioElement.id = `audio-${userId}`;
                    audioElement.autoplay = true;
                    audioElement.style.display = 'none';
                    document.body.appendChild(audioElement);
                }
                audioElement.srcObject = stream;
                
                // Apply force mute settings if user is force-muted
                if (forceMutedUsers.has(userId)) {
                    audioTracks.forEach(track => {
                        track.enabled = false;
                    });
                    console.log(`Applied force mute to audio tracks for user ${userId} during creation`);
                }
            }
        }
        
        function updateRemoteVideoElement(userId, stream) {
            console.log(`Updating video element for user ${userId}`);
            
            const existingContainer = document.getElementById(`video-container-${userId}`);
            if (existingContainer) {
                // Update existing video element
                const videoElement = document.getElementById(`video-${userId}`);
                const placeholder = existingContainer.querySelector('.no-video-placeholder');
                
                const videoTracks = stream.getVideoTracks();
                const hasVideo = videoTracks.length > 0 && videoTracks[0].enabled;
                
                if (hasVideo && !videoElement) {
                    // Remove placeholder and add video
                    if (placeholder) {
                        placeholder.remove();
                    }
                    
                    const newVideoElement = document.createElement('video');
                    newVideoElement.id = `video-${userId}`;
                    newVideoElement.srcObject = stream;
                    newVideoElement.autoplay = true;
                    newVideoElement.playsInline = true;
                    newVideoElement.muted = false;
                    
                    newVideoElement.onloadedmetadata = () => {
                        console.log(`Video metadata loaded for user ${userId}`);
                        newVideoElement.play().catch(e => console.error('Error playing video:', e));
                    };
                    
                    existingContainer.insertBefore(newVideoElement, existingContainer.querySelector('.video-overlay'));
                } else if (!hasVideo && videoElement) {
                    // Remove video and add placeholder
                    videoElement.remove();
                    
                    const newPlaceholder = document.createElement('div');
                    newPlaceholder.className = 'no-video-placeholder';
                    newPlaceholder.innerHTML = `
                        <div class="avatar">ðŸ‘¤</div>
                        <div>User ${userId.substring(0, 6)}</div>
                    `;
                    existingContainer.insertBefore(newPlaceholder, existingContainer.querySelector('.video-overlay'));
                } else if (hasVideo && videoElement) {
                    // Update existing video stream
                    videoElement.srcObject = stream;
                }
                
                // Update audio
                const audioTracks = stream.getAudioTracks();
                if (audioTracks.length > 0) {
                    let audioElement = document.getElementById(`audio-${userId}`);
                    if (!audioElement) {
                        audioElement = document.createElement('audio');
                        audioElement.id = `audio-${userId}`;
                        audioElement.autoplay = true;
                        audioElement.style.display = 'none';
                        document.body.appendChild(audioElement);
                    }
                    audioElement.srcObject = stream;
                    
                    // Apply force mute settings if user is force-muted
                    if (forceMutedUsers.has(userId)) {
                        audioTracks.forEach(track => {
                            track.enabled = false;
                        });
                        console.log(`Applied force mute to audio tracks for user ${userId}`);
                    }
                }
                
                updateVideoOverlay(userId);
            } else {
                // Create new video element
                createRemoteVideoElement(userId, stream);
            }
        }
        
        function removeVideoElement(userId) {
            // Clear focus if this video was focused
            if (focusedVideoUserId === userId) {
                focusedVideoUserId = null;
            }
            
            const videoContainer = document.getElementById(`video-container-${userId}`);
            if (videoContainer) {
                videoContainer.remove();
            }
            
            // Auto-adjust grid layout after removing video
            adjustVideoGridLayout();
        }
        
        // Auto-adjust video grid layout based on participant count
        function adjustVideoGridLayout() {
            const videoGrid = document.getElementById('videoGrid');
            const videoContainers = videoGrid.querySelectorAll('.video-container');
            const participantCount = videoContainers.length;
            
            // Remove all existing participant classes
            videoGrid.className = videoGrid.className.replace(/\bparticipants-\S+/g, '');
            
            // Add appropriate class based on participant count
            let layoutClass;
            if (participantCount === 1) {
                layoutClass = 'participants-1';
            } else if (participantCount === 2) {
                layoutClass = 'participants-2';
            } else if (participantCount === 3) {
                layoutClass = 'participants-3';
            } else if (participantCount === 4) {
                layoutClass = 'participants-4';
            } else if (participantCount <= 6) {
                layoutClass = 'participants-' + participantCount;
            } else if (participantCount <= 9) {
                layoutClass = 'participants-' + participantCount;
            } else if (participantCount <= 12) {
                layoutClass = 'participants-' + participantCount;
            } else {
                layoutClass = 'participants-more';
            }
            
            videoGrid.classList.add(layoutClass);
            
            // Update participant count display using the participants Map
            updateParticipantCount();
            
            console.log(`Grid layout adjusted for ${participantCount} participants - using class: ${layoutClass}`);
        }
        
        function updateVideoOverlay(userId) {
            const overlay = document.getElementById(`overlay-${userId}`);
            if (!overlay) return;
            
            const userInfo = participants.get(userId) || {};
            const mediaState = userInfo.mediaState || {};
            const displayName = userInfo.username || `User ${userId.substring(0, 6).toUpperCase()}`;
            const isForceMuted = forceMutedUsers.has(userId);
            const isBanned = bannedUsers.has(userId);
            
            overlay.innerHTML = `
                <div class="user-name">${displayName}</div>
                <div class="media-indicators">
                    <div class="media-indicator audio-indicator ${mediaState.audio_muted || isForceMuted ? 'muted' : 'active'}" title="Audio">
                        ${mediaState.audio_muted || isForceMuted ? 'ðŸ”‡' : 'ðŸŽ¤'}
                    </div>
                    <div class="media-indicator video-indicator ${mediaState.video_muted ? 'muted' : 'active'}" title="Video">
                        ${mediaState.video_muted ? 'ðŸ“¹' : 'ðŸ“º'}
                    </div>
                    <button class="force-mute-btn ${isForceMuted ? 'active' : ''}" 
                            onclick="toggleForceMute('${userId}')" 
                            title="${isForceMuted ? 'Unmute this user' : 'Force mute this user'}">
                        ${isForceMuted ? 'ðŸ”Š' : 'ðŸš«'}
                    </button>
                    <button class="kick-ban-btn ${isBanned ? 'banned' : ''}" 
                            onclick="kickBanUser('${userId}')" 
                            title="${isBanned ? 'User is banned' : 'Kick and ban this user'}">
                        ${isBanned ? 'â›”' : 'ðŸ‘¢'}
                    </button>
                </div>
            `;
        }
        
        function setupAudioLevelMonitoring() {
            if (localStream) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                analyser = audioContext.createAnalyser();
                const source = audioContext.createMediaStreamSource(localStream);
                source.connect(analyser);
                
                analyser.fftSize = 256;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                monitorAudioLevel();
            }
        }
        
        function monitorAudioLevel() {
            if (analyser && dataArray && !isAudioMuted) {
                analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < dataArray.length; i++) {
                    sum += dataArray[i];
                }
                const average = sum / dataArray.length;
                const percentage = (average / 255) * 100;
                
                audioLevelBar.style.width = percentage + '%';
                
                // Add speaking animation to local video
                const localContainer = document.getElementById('local-video-container');
                if (localContainer) {
                    if (percentage > 10) {
                        localContainer.classList.add('speaking');
                    } else {
                        localContainer.classList.remove('speaking');
                    }
                }
            } else {
                audioLevelBar.style.width = '0%';
            }
            
            requestAnimationFrame(monitorAudioLevel);
        }
        
        function updateServerMediaState() {
            socket.emit('update_media_state', {
                audio: isCallActive,
                video: isCallActive && isVideoEnabled,
                audio_muted: isAudioMuted,
                video_muted: isVideoMuted || !isVideoEnabled
            });
        }
        
        function cleanupSimulcast() {
            // Clear simulcast data
            currentSimulcastLayers.clear();
            layerSwitchHistory.clear();
            receiverPreferences.clear();
            
            // Clear seamless switching data
            layerTransitionBuffers.clear();
            currentReceiveLayers.clear();
            layerSwitchCooldown.clear();
            frameBuffers.clear();
            transitionStates.clear();
            
            // Reset simulcast stats
            simulcastStats = {
                activeLayers: new Set(),
                totalBytesSent: 0,
                layerBytesSent: {},
                lastLayerSwitch: 0,
                switchCount: 0
            };
            
            console.log('Simulcast cleanup completed');
        }
        
        function updateSimulcastLayerStats(userId, layerStats) {
            // Update layer-specific statistics
            Object.entries(layerStats).forEach(([rid, stats]) => {
                if (simulcastStats.layerBytesSent[rid] === undefined) {
                    simulcastStats.layerBytesSent[rid] = 0;
                }
                
                // Calculate FPS for each layer
                const framesSent = stats.framesSent || 0;
                const timestamp = Date.now();
                
                // Store previous values for FPS calculation
                if (!this.lastLayerStats) this.lastLayerStats = {};
                if (!this.lastLayerStats[rid]) this.lastLayerStats[rid] = { framesSent: 0, timestamp: timestamp };
                
                const timeDiff = (timestamp - this.lastLayerStats[rid].timestamp) / 1000;
                const framesDiff = framesSent - this.lastLayerStats[rid].framesSent;
                const fps = timeDiff > 0 ? Math.round(framesDiff / timeDiff) : 0;
                
                // Update UI
                const fpsElement = document.getElementById(`${rid}Fps`);
                if (fpsElement) {
                    fpsElement.textContent = fps;
                }
                
                // Store current values for next calculation
                this.lastLayerStats[rid] = { framesSent, timestamp };
            });
            
            // Update overall simulcast display
            updateSimulcastDisplay();
        }
        
        // UI functions
        function toggleCall() {
            if (isCallActive) {
                endCall();
            } else {
                startCall();
            }
        }
        
        function toggleAudio() {
            if (!localStream) return;
            
            const audioTrack = localStream.getAudioTracks()[0];
            if (audioTrack) {
                audioTrack.enabled = !audioTrack.enabled;
                isAudioMuted = !audioTrack.enabled;
                
                audioBtn.classList.toggle('muted', isAudioMuted);
                audioIcon.textContent = isAudioMuted ? 'ðŸ”‡' : 'ðŸŽ¤';
                
                // Update local video overlay
                createLocalVideoElement();
                
                // Notify server
                socket.emit('toggle_audio', { muted: isAudioMuted });
                updateServerMediaState();
            }
        }
        
        async function toggleVideo() {
            if (!localStream) return;
            
            const videoTrack = localStream.getVideoTracks()[0];
            if (videoTrack) {
                videoTrack.enabled = !videoTrack.enabled;
                isVideoMuted = !videoTrack.enabled;
            } else if (!isVideoMuted) {
                // Try to add video track if not present
                try {
                    console.log('Adding video track...');
                    const videoStream = await navigator.mediaDevices.getUserMedia({ 
                        video: {
                            width: { ideal: 1280, max: 1920 },
                            height: { ideal: 720, max: 1080 },
                            frameRate: { ideal: 30, max: 60 }
                        }
                    });
                    const newVideoTrack = videoStream.getVideoTracks()[0];
                    
                    // Add video track to existing stream
                    localStream.addTrack(newVideoTrack);
                    
                    // Update all peer connections with the new track
                    Object.entries(peerConnections).forEach(([userId, pc]) => {
                        console.log(`Adding video track to peer connection for user ${userId}`);
                        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (!sender) {
                            pc.addTrack(newVideoTrack, localStream);
                        } else {
                            sender.replaceTrack(newVideoTrack).catch(e => console.error('Error replacing track:', e));
                        }
                    });
                    
                    isVideoEnabled = true;
                    isVideoMuted = false;
                } catch (error) {
                    console.error('Error adding video:', error);
                    isVideoMuted = true;
                }
            }
            
            videoBtn.classList.toggle('muted', isVideoMuted || !isVideoEnabled);
            videoIcon.textContent = (isVideoMuted || !isVideoEnabled) ? 'ðŸ“¹' : 'ðŸ“º';
            
            // Update local video display
            createLocalVideoElement();
            
            // Update camera switch button availability
            await enumerateCameras();
            
            // Notify server
            socket.emit('toggle_video', { muted: isVideoMuted || !isVideoEnabled });
            updateServerMediaState();
        }
        
        // Camera switching functions
        async function enumerateCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                console.log('Available cameras:', availableCameras.length);
                
                // Enable camera switch button only if multiple cameras are available
                if (availableCameras.length > 1 && isVideoEnabled && !isVideoMuted) {
                    cameraSwitchBtn.disabled = false;
                    cameraSwitchBtn.style.opacity = '1';
                    cameraSwitchBtn.title = `Switch Camera (${availableCameras.length} available)`;
                } else {
                    cameraSwitchBtn.disabled = true;
                    cameraSwitchBtn.style.opacity = '0.5';
                    cameraSwitchBtn.title = availableCameras.length <= 1 ? 'Only one camera available' : 'Enable video to switch cameras';
                }
                
                return availableCameras;
            } catch (error) {
                console.error('Error enumerating cameras:', error);
                return [];
            }
        }
        
        async function switchCamera() {
            if (isSwitchingCamera || !isVideoEnabled || isVideoMuted || availableCameras.length <= 1) {
                console.log('Cannot switch camera:', { isSwitchingCamera, isVideoEnabled, isVideoMuted, camerasCount: availableCameras.length });
                return;
            }
            
            try {
                isSwitchingCamera = true;
                cameraSwitchBtn.classList.add('switching');
                cameraSwitchIcon.textContent = 'â³';
                
                // Determine next camera
                let nextCameraId = null;
                let nextFacingMode = currentFacingMode;
                
                if (currentCameraDeviceId) {
                    // Find current camera index and switch to next
                    const currentIndex = availableCameras.findIndex(camera => camera.deviceId === currentCameraDeviceId);
                    const nextIndex = (currentIndex + 1) % availableCameras.length;
                    nextCameraId = availableCameras[nextIndex].deviceId;
                } else {
                    // Switch between front and back cameras using facingMode
                    nextFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                }
                
                // Create new stream with next camera
                const constraints = {
                    video: {
                        width: { ideal: 1280, max: 1280 },
                        height: { ideal: 720, max: 720 },
                        frameRate: { ideal: 30, max: 30 }
                    }
                };
                
                if (nextCameraId) {
                    constraints.video.deviceId = { exact: nextCameraId };
                } else {
                    constraints.video.facingMode = { ideal: nextFacingMode };
                }
                
                console.log('Switching to camera with constraints:', constraints);
                
                const newStream = await navigator.mediaDevices.getUserMedia(constraints);
                const newVideoTrack = newStream.getVideoTracks()[0];
                
                if (!newVideoTrack) {
                    throw new Error('No video track in new stream');
                }
                
                // Update camera info
                currentCameraDeviceId = newVideoTrack.getSettings().deviceId;
                currentFacingMode = newVideoTrack.getSettings().facingMode || nextFacingMode;
                
                console.log('New camera settings:', newVideoTrack.getSettings());
                
                // Replace video track in all peer connections
                const replacePromises = Object.values(peerConnections).map(async (pc) => {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        await sender.replaceTrack(newVideoTrack);
                        console.log('Replaced video track in peer connection');
                    }
                });
                
                await Promise.all(replacePromises);
                
                // Update local stream
                if (localStream) {
                    const oldVideoTrack = localStream.getVideoTracks()[0];
                    if (oldVideoTrack) {
                        localStream.removeTrack(oldVideoTrack);
                        oldVideoTrack.stop(); // Stop the old track
                    }
                    localStream.addTrack(newVideoTrack);
                }
                
                // Update local video element
                createLocalVideoElement();
                
                // Update button icon based on camera type
                const settings = newVideoTrack.getSettings();
                if (settings.facingMode === 'environment' || currentFacingMode === 'environment') {
                    cameraSwitchIcon.textContent = 'ðŸ“·'; // Back camera
                } else {
                    cameraSwitchIcon.textContent = 'ðŸ¤³'; // Front camera
                }
                
                console.log('Camera switched successfully to:', settings.facingMode || 'unknown');
                
            } catch (error) {
                console.error('Error switching camera:', error);
                alert('Failed to switch camera. Please check camera permissions and try again.');
                
                // Reset icon on error
                cameraSwitchIcon.textContent = 'ðŸ”„';
            } finally {
                isSwitchingCamera = false;
                cameraSwitchBtn.classList.remove('switching');
                
                // Reset icon if not set above
                if (cameraSwitchIcon.textContent === 'â³') {
                    cameraSwitchIcon.textContent = 'ðŸ”„';
                }
            }
        }
        
        // Video Focus/Zoom Functions
        function focusVideo(userId) {
            if (!videoFocusEnabled) return;
            
            console.log('Focusing video for user:', userId);
            
            // If clicking on already focused video, unfocus it
            if (focusedVideoUserId === userId) {
                unfocusAllVideos();
                return;
            }
            
            // Unfocus any previously focused video
            unfocusAllVideos();
            
            // Focus the clicked video
            const videoContainer = document.getElementById(`video-container-${userId}`);
            if (videoContainer) {
                videoContainer.classList.add('focused');
                focusedVideoUserId = userId;
                console.log('Video focused for user:', userId);
            }
        }
        
        function unfocusAllVideos() {
            // Remove focus from all videos
            const allVideoContainers = document.querySelectorAll('.video-container');
            allVideoContainers.forEach(container => {
                container.classList.remove('focused');
            });
            
            focusedVideoUserId = null;
            console.log('All videos unfocused');
        }
        
        function attachVideoFocusHandler(userId) {
            const videoContainer = document.getElementById(`video-container-${userId}`);
            if (videoContainer && !videoContainer.hasAttribute('data-focus-attached')) {
                videoContainer.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    focusVideo(userId);
                });
                
                // Mark as having focus handler attached
                videoContainer.setAttribute('data-focus-attached', 'true');
                console.log('Focus handler attached for user:', userId);
            }
        }
        
        function updateConnectionStatus(message, className) {
            connectionStatus.textContent = message;
            connectionStatus.className = `status ${className}`;
        }
        
        function updateParticipantCount() {
            // Include local user in the total count (add 1 to participants.size)
            const count = participants.size + 1;
            const countText = count === 1 ? 'ðŸ‘¥ 1 Participant' : `ðŸ‘¥ ${count} Participants`;
            participantCount.textContent = countText;
            
            // Update chat sidebar participant count if it exists (also include local user)
            const chatParticipantCount = document.getElementById('chatParticipantCount');
            if (chatParticipantCount) {
                chatParticipantCount.textContent = count;
            }
        }
        
        // Force mute functionality
        function toggleForceMute(userId) {
            if (forceMutedUsers.has(userId)) {
                // Unmute the user
                forceMutedUsers.delete(userId);
                setUserAudioMuted(userId, false);
                console.log(`User ${userId} force-unmuted locally`);
                showNotification(`${getUserDisplayName(userId)} unmuted`, 'info');
            } else {
                // Mute the user
                forceMutedUsers.add(userId);
                setUserAudioMuted(userId, true);
                console.log(`User ${userId} force-muted locally`);
                showNotification(`${getUserDisplayName(userId)} muted locally`, 'warning');
            }
            
            // Update the overlay to reflect the change
            updateVideoOverlay(userId);
        }
        
        function setUserAudioMuted(userId, muted) {
            // Find the peer connection for this user
            const peerConnection = peerConnections[userId];
            if (!peerConnection) {
                console.warn(`No peer connection found for user ${userId}`);
                return;
            }
            
            // Get all receivers from the peer connection
            const receivers = peerConnection.getReceivers();
            
            // Find audio tracks and mute/unmute them
            receivers.forEach(receiver => {
                if (receiver.track && receiver.track.kind === 'audio') {
                    receiver.track.enabled = !muted;
                    console.log(`${muted ? 'Muted' : 'Unmuted'} audio track for user ${userId}`);
                }
            });
        }
        
        function getUserDisplayName(userId) {
            const userInfo = participants.get(userId);
            return userInfo ? userInfo.username : `User ${userId.substring(0, 6).toUpperCase()}`;
        }
        
        function showNotification(message, type = 'info') {
            // Create notification element
            const notification = document.createElement('div');
            notification.className = `notification notification-${type}`;
            notification.textContent = message;
            
            // Style the notification
            Object.assign(notification.style, {
                position: 'fixed',
                top: '80px',
                right: '20px',
                padding: '12px 20px',
                borderRadius: '8px',
                color: 'white',
                fontSize: '14px',
                fontWeight: '500',
                zIndex: '1002',
                opacity: '0',
                transform: 'translateX(100%)',
                transition: 'all 0.3s ease',
                maxWidth: '300px',
                wordWrap: 'break-word'
            });
            
            // Set background color based on type
            const colors = {
                'info': 'linear-gradient(135deg, #2196F3, #1976d2)',
                'success': 'linear-gradient(135deg, #4CAF50, #388e3c)',
                'warning': 'linear-gradient(135deg, #FF9800, #f57c00)',
                'error': 'linear-gradient(135deg, #f44336, #d32f2f)'
            };
            notification.style.background = colors[type] || colors.info;
            
            // Add to page
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateX(0)';
            }, 10);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateX(100%)';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }
        
        // Kick and ban functionality
        function kickBanUser(userId) {
            const displayName = getUserDisplayName(userId);
            
            if (bannedUsers.has(userId)) {
                showNotification(`${displayName} is already banned`, 'info');
                return;
            }
            
            if (confirm(`Are you sure you want to kick and ban "${displayName}" from this room?\n\nThis user will not be able to rejoin with the same ID.`)) {
                // Add to banned list
                bannedUsers.add(userId);
                
                // Force mute them as well
                forceMutedUsers.add(userId);
                setUserAudioMuted(userId, true);
                
                // Close peer connection
                if (peerConnections[userId]) {
                    peerConnections[userId].close();
                    delete peerConnections[userId];
                }
                
                // Remove from participants
                participants.delete(userId);
                updateParticipantCount();
                
                // Remove video element
                removeVideoElement(userId);
                
                // Notify server about the ban
                socket.emit('ban_user', { 
                    room_id: roomId, 
                    banned_user_id: userId,
                    banned_username: displayName 
                });
                
                // Update overlay for any remaining traces
                updateVideoOverlay(userId);
                
                console.log(`User ${userId} has been kicked and banned`);
                showNotification(`${displayName} has been kicked and banned`, 'warning');
            }
        }
        
        function isUserBanned(userId) {
            return bannedUsers.has(userId);
        }
        
        function preventBannedUserJoin(userId) {
            if (bannedUsers.has(userId)) {
                console.log(`Preventing banned user ${userId} from joining`);
                socket.emit('reject_banned_user', { 
                    room_id: roomId, 
                    banned_user_id: userId 
                });
                return true;
            }
            return false;
        }
        
        function leaveRoom() {
            if (confirm('Are you sure you want to leave the room?')) {
                // End the call first
                if (isCallActive) {
                    endCall();
                }
                
                // Emit leave room event
                socket.emit('leave_room', { room_id: roomId });
                
                // Redirect to home page or close window
                window.location.href = '/';
            }
        }
        
        function toggleChat() {
            const chatSidebar = document.getElementById('chatSidebar');
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('chatToggleBtn');
            const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isMobileScreen = window.innerWidth <= 768;
            
            console.log('Toggle chat called - Mobile Device:', isMobileDevice, 'Mobile Screen:', isMobileScreen);
            
            if (!chatSidebar || !toggleBtn) {
                console.error('Chat sidebar or toggle button not found');
                return;
            }
            
            // Define states for floating chat: visible, collapsed, hidden
            if (chatSidebar.classList.contains('hidden')) {
                // From hidden to visible - Floating above main content
                chatSidebar.classList.remove('hidden');
                toggleBtn.textContent = 'â—€ï¸';
                toggleBtn.title = 'Minimize Chat';
                updateLayoutStatus(isMobileDevice || isMobileScreen ? 'ðŸ“± Floating Chat' : 'ðŸŽ¯ Floating Chat + Full Video', 'Chat floating above with full-width video');
                showToast('Floating Chat Activated', 'success');
                
                // Force to floating position and expand video
                forceChatToForeground();
                setTimeout(() => expandVideoConferencingRoom(), 200);
                updateLayoutStatus(isMobileDevice || isMobileScreen ? 'ï¿½ Mobile Chat Mode' : 'ï¿½ðŸ’» Normal Layout Mode', 'Chat restored');
                showToast('Chat restored', 'success');
            } else if (chatSidebar.classList.contains('collapsed')) {
                // From collapsed to normal - Auto-expand video room
                chatSidebar.classList.remove('collapsed');
                container.classList.remove('chat-collapsed');
                container.classList.add('chat-foreground-expanded'); // Auto-expand video
                toggleBtn.textContent = 'â—€ï¸';
                toggleBtn.title = 'Minimize Chat';
                updateLayoutStatus(isMobileDevice || isMobileScreen ? 'ðŸ“± Mobile + Expanded Video' : 'ðŸŽ¯ Chat + Expanded Video Mode', 'Chat expanded with maximized video');
                showToast('Chat expanded - Video room maximized', 'success');
                
                // Force chat to foreground and trigger expansion
                forceChatToForeground();
                setTimeout(() => expandVideoConferencingRoom(), 200);
            } else {
                // From visible to collapsed - Still floating but minimized
                chatSidebar.classList.add('collapsed');
                toggleBtn.textContent = 'â–¶ï¸';
                toggleBtn.title = 'Expand Chat';
                updateLayoutStatus(isMobileDevice || isMobileScreen ? 'ðŸ“± Floating Chat (Mini)' : 'ðŸŽ¯ Floating Chat (Mini)', 'Chat minimized but still floating above');
                showToast('Chat Minimized (Still Floating)', 'info');
            }
            
            // Trigger layout adjustment animations
            setTimeout(() => {
                updateVideoGridLayout();
                window.dispatchEvent(new Event('resize'));
            }, 100);
            
            // Add smooth transition effects
            setTimeout(() => {
                const videoGrid = document.querySelector('.video-grid');
                if (videoGrid) {
                    videoGrid.style.transform += ' translateZ(0)';
                }
            }, 300);
        }
        
        // Add double-click to toggle between normal and hidden states
        function doubleTapChat() {
            const chatSidebar = document.getElementById('chatSidebar');
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('chatToggleBtn');
            
            if (chatSidebar.classList.contains('hidden')) {
                // Restore from hidden
                chatSidebar.classList.remove('hidden');
                container.classList.remove('fullscreen-video');
                toggleBtn.textContent = 'â—€ï¸';
                toggleBtn.title = 'Minimize Chat';
                updateLayoutStatus('ðŸ’» Normal Layout Mode', 'Full video mode disabled');
                showToast('Chat restored - Full video mode disabled', 'success');
            } else {
                // Hide completely for full video mode
                chatSidebar.classList.remove('collapsed');
                chatSidebar.classList.add('hidden');
                container.classList.remove('chat-collapsed');
                container.classList.add('fullscreen-video');
                toggleBtn.textContent = 'ðŸ’¬';
                toggleBtn.title = 'Show Chat';
                updateLayoutStatus('ðŸŽ¬ Full Video Mode', 'Maximum space for video conferencing');
                showToast('Full video mode enabled', 'info');
            }
            
            setTimeout(() => {
                updateVideoGridLayout();
                window.dispatchEvent(new Event('resize'));
            }, 100);
        }
        
        // Chat foreground icon functionality
        function initChatForegroundIcon() {
            const foregroundIcon = document.querySelector('.chat-foreground-icon');
            if (foregroundIcon) {
                // Add click effect and auto-expand video room
                foregroundIcon.addEventListener('click', function() {
                    this.style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        this.style.transform = 'scale(1)';
                    }, 150);
                    
                    // Force chat to foreground first
                    forceChatToForeground();
                    
                    // Auto-expand video conferencing room to full window
                    expandVideoConferencingRoom();
                    
                    // Show chat activity indicator
                    showToast('ðŸ’¬ Chat Floating Active - Video Expanded', 'success');
                });
                
                // Pulse effect on new messages
                window.addEventListener('newChatMessage', function() {
                    foregroundIcon.style.animation = 'none';
                    setTimeout(() => {
                        foregroundIcon.style.animation = 'chatPulse 1s ease-in-out 3';
                    }, 10);
                });
            }
        }
        
        // Auto-expand video conferencing room when chat floats above - no 3D
        function expandVideoConferencingRoom() {
            const container = document.querySelector('.container');
            const videoGrid = document.querySelector('.video-grid');
            const chatSidebar = document.getElementById('chatSidebar');
            const mainContent = document.querySelector('.main-content');
            
            if (!container || !videoGrid || !chatSidebar || !mainContent) return;
            
            // Since chat floats, main content can use full width
            mainContent.style.cssText += `
                width: 100% !important;
                max-width: 100% !important;
                padding-right: 0 !important;
            `;
            
            // Expand video grid to utilize full screen space - no 3D transforms
            videoGrid.style.cssText += `
                width: 100% !important;
                max-width: 100% !important;
                height: calc(100vh - 150px) !important;
                z-index: 1 !important;
            `;
            
            // Simple floating chat positioning - no 3D
            chatSidebar.style.cssText += `
                position: fixed !important;
                top: 24px !important;
                right: 24px !important;
                z-index: 9999999 !important;
            `;
            
            // Update grid layout for expanded view
            setTimeout(() => {
                updateVideoGridLayout();
                adjustVideoGridLayout();
            }, 100);
            
            // Update layout status
            updateLayoutStatus('ðŸŽ¯ Floating Chat + Full Video', 'Chat floating above with full-width video conferencing');
            
            console.log('Video expanded to full width with simple floating chat above');
        }
        
        // Force chat to simple floating position above main content - no 3D
        function forceChatToForeground() {
            const chatSidebar = document.getElementById('chatSidebar');
            const chatContent = document.querySelector('.chat-content');
            const chatIcon = document.querySelector('.chat-foreground-icon');
            const videoGrid = document.querySelector('.video-grid');
            const mainContent = document.querySelector('.main-content');
            
            if (chatSidebar) {
                // Apply simple floating positioning - no 3D transforms
                chatSidebar.style.cssText += `
                    position: fixed !important;
                    top: 24px !important;
                    right: 24px !important;
                    z-index: 9999999 !important;
                `;
                
                // Remove any grid-affecting classes
                chatSidebar.classList.remove('hidden', 'collapsed');
            }
            
            if (chatContent) {
                chatContent.style.cssText += `
                    z-index: inherit !important;
                    position: relative !important;
                `;
            }
            
            if (chatIcon) {
                chatIcon.style.cssText += `
                    z-index: 10000000 !important;
                    position: absolute !important;
                `;
            }
            
            // Allow main content to use full width since chat floats
            if (mainContent) {
                mainContent.style.cssText += `
                    width: 100% !important;
                    max-width: 100% !important;
                    z-index: 1 !important;
                    position: relative !important;
                `;
            }
            
            // Ensure video grid uses full available space - no 3D
            if (videoGrid) {
                videoGrid.style.cssText += `
                    width: 100% !important;
                    max-width: 100% !important;
                    z-index: 1 !important;
                    position: relative !important;
                `;
            }
            
            console.log('Chat positioned as simple floating overlay above main content');
        }
        
        // Initialize mobile chat toggle functionality
        function initializeMobileChatToggle() {
            const chatToggleBtn = document.getElementById('chatToggleBtn');
            const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isMobileScreen = window.innerWidth <= 768;
            
            if ((isMobileDevice || isMobileScreen) && chatToggleBtn) {
                console.log('Initializing mobile chat toggle functionality');
                
                // Remove existing event listeners to prevent conflicts
                chatToggleBtn.onclick = null;
                chatToggleBtn.removeAttribute('onclick');
                
                // Remove all existing event listeners
                const newBtn = chatToggleBtn.cloneNode(true);
                chatToggleBtn.parentNode.replaceChild(newBtn, chatToggleBtn);
                
                // Get the new button reference
                const btn = document.getElementById('chatToggleBtn');
                
                // Add multiple event types for maximum compatibility
                btn.addEventListener('touchstart', handleMobileChatToggle, { passive: false });
                btn.addEventListener('touchend', handleMobileChatToggle, { passive: false });
                btn.addEventListener('click', handleMobileChatToggle, { passive: false });
                btn.addEventListener('mousedown', handleMobileChatToggle, { passive: false });
                
                // Ensure button is properly positioned and visible
                btn.style.cssText += `
                    position: absolute !important;
                    top: 16px !important;
                    right: 16px !important;
                    z-index: 10000001 !important;
                    pointer-events: auto !important;
                    touch-action: manipulation !important;
                    display: block !important;
                    visibility: visible !important;
                    opacity: 1 !important;
                `;
                
                // Add a fallback click handler
                btn.onclick = function(e) {
                    e.preventDefault();
                    e.stopPropagation();
                    console.log('Fallback click handler triggered');
                    toggleChat();
                };
                
                console.log('Mobile chat toggle initialized successfully');
            }
        }
        
        // Handle mobile chat toggle events
        function handleMobileChatToggle(event) {
            event.preventDefault();
            event.stopPropagation();
            
            console.log('Mobile chat toggle triggered:', event.type);
            
            // Only handle touchend and click events to avoid double triggers
            if (event.type === 'touchstart') {
                // Visual feedback for touch start
                const btn = event.target;
                btn.style.transform = 'scale(0.95)';
                btn.style.background = 'rgba(255, 255, 255, 0.4)';
                return;
            }
            
            if (event.type === 'touchend' || event.type === 'click') {
                // Reset visual feedback
                const btn = event.target;
                btn.style.transform = 'scale(1)';
                btn.style.background = '';
                
                // Trigger the toggle function
                setTimeout(() => {
                    toggleChat();
                }, 100);
            }
        }
        
        // Update Layout Status Indicator
        function updateLayoutStatus(modeText, description) {
            const layoutModeText = document.getElementById('layoutModeText');
            const layoutStatus = document.getElementById('layoutStatus');
            
            if (layoutModeText) {
                layoutModeText.textContent = modeText;
            }
            
            if (layoutStatus) {
                // Add animation
                layoutStatus.style.transform = 'scale(1.05)';
                layoutStatus.style.background = 'rgba(102, 126, 234, 0.2)';
                
                setTimeout(() => {
                    layoutStatus.style.transform = 'scale(1)';
                    layoutStatus.style.background = 'rgba(255, 255, 255, 0.1)';
                }, 200);
                
                // Update description if provided
                if (description) {
                    const descSpan = layoutStatus.querySelector('span:last-child');
                    if (descSpan) {
                        descSpan.textContent = description;
                        setTimeout(() => {
                            descSpan.textContent = "Press 'C' to toggle chat";
                        }, 3000);
                    }
                }
            }
        }
        
        function toggleNoiseControls() {
            if (noiseControls.style.display === 'none' || noiseControls.style.display === '') {
                noiseControls.style.display = 'block';
            } else {
                noiseControls.style.display = 'none';
            }
        }
        
        // Dynamic Video Grid Layout Update - Enhanced for better serial arrangement
        function updateVideoGridLayout() {
            const videoGrid = document.querySelector('.video-grid');
            const container = document.querySelector('.container');
            const videoContainers = document.querySelectorAll('.video-container');
            const participantCount = videoContainers.length;
            
            if (!videoGrid) return;
            
            // Remove existing participant classes
            videoGrid.className = videoGrid.className.replace(/participants-\d+|participants-more/g, '');
            
            // Determine layout based on participant count for proper serial arrangement
            let gridClass = 'participants-1';
            
            if (participantCount <= 1) {
                gridClass = 'participants-1';
            } else if (participantCount === 2) {
                gridClass = 'participants-2';
            } else if (participantCount === 3) {
                gridClass = 'participants-3';
            } else if (participantCount === 4) {
                gridClass = 'participants-4';
            } else if (participantCount <= 6) {
                gridClass = 'participants-6';
            } else if (participantCount <= 9) {
                gridClass = 'participants-9';
            } else if (participantCount <= 12) {
                gridClass = 'participants-12';
            } else if (participantCount <= 16) {
                gridClass = 'participants-16';
            } else {
                gridClass = 'participants-more';
            }
            
            videoGrid.classList.add(gridClass);
            
            // Add participant count indicator for debugging
            const participantCountElement = document.getElementById('participantCount');
            const gridInfoElement = document.getElementById('gridInfo');
            if (participantCountElement) {
                participantCountElement.textContent = `${participantCount} participant${participantCount !== 1 ? 's' : ''}`;
            }
            if (gridInfoElement) {
                gridInfoElement.textContent = getGridDescription(gridClass);
            }
            
            // Adjust video container sizes and ensure proper serial ordering
            videoContainers.forEach((container, index) => {
                // Set a data attribute for serial ordering
                container.setAttribute('data-participant-index', index + 1);
                
                // Add serial number overlay for visual reference
                let serialLabel = container.querySelector('.participant-serial');
                if (!serialLabel) {
                    serialLabel = document.createElement('div');
                    serialLabel.className = 'participant-serial';
                    serialLabel.style.cssText = `
                        position: absolute;
                        top: 8px;
                        left: 8px;
                        background: rgba(0, 0, 0, 0.7);
                        color: white;
                        padding: 4px 8px;
                        border-radius: 12px;
                        font-size: 12px;
                        font-weight: bold;
                        z-index: 10;
                        pointer-events: none;
                    `;
                    container.appendChild(serialLabel);
                }
                serialLabel.textContent = `#${index + 1}`;
                
                // Add zoom button for each video container
                let zoomBtn = container.querySelector('.zoom-btn');
                if (!zoomBtn) {
                    zoomBtn = document.createElement('button');
                    zoomBtn.className = 'zoom-btn';
                    zoomBtn.innerHTML = 'ðŸ”';
                    zoomBtn.title = 'Zoom Video';
                    zoomBtn.onclick = (e) => {
                        e.stopPropagation();
                        zoomVideo(container, index + 1);
                    };
                    container.appendChild(zoomBtn);
                }
                
                // Add double-click to zoom functionality
                container.ondblclick = (e) => {
                    e.preventDefault();
                    zoomVideo(container, index + 1);
                };
                
                // Add single click for focus/selection
                container.onclick = (e) => {
                    e.preventDefault();
                    // Remove selection from other containers
                    document.querySelectorAll('.video-container').forEach(c => c.classList.remove('selected'));
                    // Add selection to clicked container
                    container.classList.add('selected');
                    showToast(`Selected Participant #${index + 1} â€¢ Double-click to zoom`, 'info');
                };
                
                // Add hover tooltip for zoom
                container.title = `Participant #${index + 1} â€¢ Double-click to zoom â€¢ Click zoom button (ðŸ”) for zoom options`;
                
                // Add mouse enter/leave for better UX
                container.onmouseenter = () => {
                    if (!container.classList.contains('selected')) {
                        container.style.transform += ' translateY(-2px)';
                    }
                };
                
                container.onmouseleave = () => {
                    if (!container.classList.contains('selected')) {
                        // Reset transform based on chat state
                        if (document.querySelector('.container').classList.contains('fullscreen-video')) {
                            container.style.transform = 'scale(1.05)';
                        } else if (document.querySelector('.container').classList.contains('chat-collapsed')) {
                            container.style.transform = 'scale(1.02)';
                        } else {
                            container.style.transform = 'scale(1)';
                        }
                    }
                };
                
                // Adjust transforms based on chat state
                if (document.querySelector('.container').classList.contains('fullscreen-video')) {
                    container.style.transform = 'scale(1.05)';
                } else if (document.querySelector('.container').classList.contains('chat-collapsed')) {
                    container.style.transform = 'scale(1.02)';
                } else {
                    container.style.transform = 'scale(1)';
                }
            });
            
            // Auto-scroll to show newly added participants
            if (participantCount > 9) {
                setTimeout(() => {
                    const lastContainer = videoContainers[videoContainers.length - 1];
                    if (lastContainer) {
                        lastContainer.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'nearest',
                            inline: 'nearest'
                        });
                    }
                }, 300);
            }
            
            // Add smooth animation
            videoGrid.style.transition = 'all 0.6s cubic-bezier(0.25, 0.46, 0.45, 0.94)';
            
            // Update layout status
            updateLayoutStatus(
                `ðŸ‘¥ ${participantCount} Participant${participantCount !== 1 ? 's' : ''}`,
                `Grid layout: ${getGridDescription(gridClass)}`
            );
        }
        
        // Helper function to get grid description
        function getGridDescription(gridClass) {
            const descriptions = {
                'participants-1': '1Ã—1 grid',
                'participants-2': '2Ã—1 grid',
                'participants-3': '2Ã—2 grid (3rd centered)',
                'participants-4': '2Ã—2 grid',
                'participants-6': '3Ã—2 grid',
                'participants-9': '3Ã—3 grid',
                'participants-12': '4Ã—3 grid',
                'participants-16': '4Ã—4 grid',
                'participants-more': '5Ã—N grid (scrollable)'
            };
            return descriptions[gridClass] || 'Custom grid';
        }
        
        // Video Zoom Functions
        let currentZoomedVideo = null;
        let isZoomFullscreen = false;
        
        function zoomVideo(videoContainer, participantIndex) {
            const overlay = document.getElementById('videoZoomOverlay');
            const zoomContainer = document.getElementById('videoZoomContainer');
            
            if (!overlay || !zoomContainer) {
                console.error('Zoom overlay elements not found');
                return;
            }
            
            // Find the video element in the container
            const videoElement = videoContainer.querySelector('video');
            
            // Clear previous content first
            zoomContainer.innerHTML = '';
            
            if (!videoElement) {
                // Create a placeholder if no video is found
                const placeholder = document.createElement('div');
                placeholder.style.cssText = `
                    width: 100%;
                    height: 100%;
                    background: linear-gradient(135deg, #667eea, #764ba2);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    color: white;
                    font-size: 24px;
                    border-radius: 20px;
                `;
                placeholder.innerHTML = `
                    <div style="text-align: center;">
                        <div style="font-size: 48px; margin-bottom: 16px;">ðŸ‘¤</div>
                        <div>Participant #${participantIndex}</div>
                        <div style="font-size: 14px; opacity: 0.8; margin-top: 8px;">No video stream available</div>
                    </div>
                `;
                zoomContainer.appendChild(placeholder);
            } else {
                // Create a new video element and copy the source
                const zoomedVideo = document.createElement('video');
                zoomedVideo.autoplay = true;
                zoomedVideo.muted = videoElement.muted;
                zoomedVideo.playsInline = true;
                zoomedVideo.style.cssText = `
                    width: 100%;
                    height: 100%;
                    object-fit: cover;
                    border-radius: 20px;
                    background: #000;
                `;
                
                // Copy the video source
                if (videoElement.srcObject) {
                    zoomedVideo.srcObject = videoElement.srcObject;
                } else if (videoElement.src) {
                    zoomedVideo.src = videoElement.src;
                }
                
                // Add the video to zoom container
                zoomContainer.appendChild(zoomedVideo);
                
                // Store reference to current zoomed video
                currentZoomedVideo = zoomedVideo;
                
                // Ensure video plays
                zoomedVideo.play().catch(console.error);
            }
            
            // Create and add controls
            const controlsDiv = document.createElement('div');
            controlsDiv.className = 'video-zoom-controls';
            controlsDiv.innerHTML = `
                <button class="video-zoom-btn" onclick="toggleZoomFullscreen()" title="Toggle Fullscreen">
                    ðŸ”³
                </button>
                <button class="video-zoom-btn" onclick="togglePictureInPicture()" title="Picture in Picture">
                    ðŸ“º
                </button>
                <button class="video-zoom-btn" onclick="closeVideoZoom()" title="Close Zoom">
                    âœ•
                </button>
            `;
            zoomContainer.appendChild(controlsDiv);
            
            // Create and add info
            const infoDiv = document.createElement('div');
            infoDiv.className = 'video-zoom-info';
            const participantName = videoContainer.querySelector('.participant-name')?.textContent || `Participant #${participantIndex}`;
            const videoWidth = videoElement?.videoWidth || 'Unknown';
            const videoHeight = videoElement?.videoHeight || 'Unknown';
            
            infoDiv.innerHTML = `
                <h4>ðŸ‘¤ ${participantName}</h4>
                <p>Resolution: ${videoWidth}Ã—${videoHeight} â€¢ Press ESC to close</p>
            `;
            zoomContainer.appendChild(infoDiv);
            
            // Show overlay with animation and force proper positioning
            overlay.style.display = 'flex';
            overlay.style.position = 'fixed';
            overlay.style.top = '0';
            overlay.style.left = '0';
            overlay.style.width = '100vw';
            overlay.style.height = '100vh';
            overlay.style.zIndex = '999999';
            
            // Ensure container is properly positioned
            zoomContainer.style.position = 'absolute';
            zoomContainer.style.top = '50%';
            zoomContainer.style.left = '50%';
            zoomContainer.style.transform = 'translate(-50%, -50%) scale(0.8)';
            zoomContainer.style.zIndex = '1000000';
            
            setTimeout(() => {
                overlay.classList.add('active');
            }, 10);
            
            // Prevent body scrolling and ensure overlay is on top
            document.body.style.overflow = 'hidden';
            document.body.style.position = 'relative';
            document.body.style.zIndex = 'auto';
            
            showToast(`ðŸ” Zoomed into ${participantName}`, 'success');
            console.log('Zoom overlay should now be visible');
            
            // Add keyboard support
            document.addEventListener('keydown', handleZoomKeyboard);
        }
        
        function closeVideoZoom() {
            const overlay = document.getElementById('videoZoomOverlay');
            if (!overlay) return;
            
            // Add closing animation
            const zoomContainer = document.getElementById('videoZoomContainer');
            if (zoomContainer) {
                zoomContainer.style.animation = 'zoomOut 0.3s ease forwards';
            }
            
            // Hide overlay after animation
            setTimeout(() => {
                overlay.classList.remove('active');
                overlay.style.display = 'none';
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.zIndex = '';
                currentZoomedVideo = null;
                isZoomFullscreen = false;
                
                // Clear the container and reset position
                if (zoomContainer) {
                    zoomContainer.innerHTML = '';
                    zoomContainer.style.animation = '';
                    // Reset to centered position with proper z-index
                    zoomContainer.style.transform = 'translate(-50%, -50%) scale(0.8)';
                    zoomContainer.style.position = 'absolute';
                    zoomContainer.style.top = '50%';
                    zoomContainer.style.left = '50%';
                    zoomContainer.style.zIndex = '1000000';
                }
            }, 300);
            
            // Remove keyboard listener
            document.removeEventListener('keydown', handleZoomKeyboard);
            
            // Exit fullscreen if active
            if (document.fullscreenElement) {
                document.exitFullscreen().catch(console.error);
            }
            
            showToast('ðŸ” Zoom closed', 'info');
        }
        
        function toggleZoomFullscreen() {
            const zoomContainer = document.getElementById('videoZoomContainer');
            if (!zoomContainer) return;
            
            if (!isZoomFullscreen) {
                // Enter fullscreen
                if (zoomContainer.requestFullscreen) {
                    zoomContainer.requestFullscreen();
                } else if (zoomContainer.webkitRequestFullscreen) {
                    zoomContainer.webkitRequestFullscreen();
                } else if (zoomContainer.msRequestFullscreen) {
                    zoomContainer.msRequestFullscreen();
                }
                isZoomFullscreen = true;
                document.getElementById('fullscreenBtn').innerHTML = 'ðŸ”²';
                showToast('Entered fullscreen mode', 'success');
            } else {
                // Exit fullscreen
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                } else if (document.webkitExitFullscreen) {
                    document.webkitExitFullscreen();
                } else if (document.msExitFullscreen) {
                    document.msExitFullscreen();
                }
                isZoomFullscreen = false;
                document.getElementById('fullscreenBtn').innerHTML = 'ðŸ”³';
                showToast('Exited fullscreen mode', 'info');
            }
        }
        
        function togglePictureInPicture() {
            if (!currentZoomedVideo) {
                showToast('No video available for Picture-in-Picture', 'warning');
                return;
            }
            
            if (document.pictureInPictureElement) {
                // Exit PiP
                document.exitPictureInPicture().then(() => {
                    showToast('Exited Picture-in-Picture mode', 'info');
                }).catch(err => {
                    showToast('Failed to exit Picture-in-Picture', 'error');
                });
            } else {
                // Enter PiP
                if (currentZoomedVideo.requestPictureInPicture) {
                    currentZoomedVideo.requestPictureInPicture().then(() => {
                        showToast('Entered Picture-in-Picture mode', 'success');
                    }).catch(err => {
                        showToast('Picture-in-Picture not supported', 'warning');
                    });
                } else {
                    showToast('Picture-in-Picture not supported by this browser', 'warning');
                }
            }
        }
        
        function handleZoomKeyboard(event) {
            if (!document.getElementById('videoZoomOverlay').classList.contains('active')) return;
            
            switch(event.key) {
                case 'Escape':
                    event.preventDefault();
                    closeVideoZoom();
                    break;
                case 'f':
                case 'F':
                    event.preventDefault();
                    toggleZoomFullscreen();
                    break;
                case 'p':
                case 'P':
                    event.preventDefault();
                    togglePictureInPicture();
                    break;
            }
        }
        
        // Click outside to close zoom
        document.addEventListener('click', function(event) {
            const overlay = document.getElementById('videoZoomOverlay');
            if (overlay && overlay.classList.contains('active') && event.target === overlay) {
                closeVideoZoom();
            }
        });
        
        // Screen Sharing Functions
        function toggleScreenControls() {
            if (screenControls.style.display === 'none' || screenControls.style.display === '') {
                screenControls.style.display = 'block';
                
                // Show mobile warning if on mobile device
                const mobileWarning = document.getElementById('mobileWarning');
                if (isMobile && mobileWarning) {
                    mobileWarning.style.display = 'block';
                    // Hide screen sharing options on mobile
                    document.getElementById('screenOptions').style.display = 'none';
                    document.getElementById('startShareBtn').style.display = 'none';
                } else if (mobileWarning) {
                    mobileWarning.style.display = 'none';
                    document.getElementById('screenOptions').style.display = 'block';
                    document.getElementById('startShareBtn').style.display = 'inline-block';
                }
            } else {
                screenControls.style.display = 'none';
            }
        }
        
        async function toggleScreenShare() {
            // Check if screen sharing is supported
            if (isMobile) {
                alert('Screen sharing is not supported on mobile devices. Please use a desktop browser for screen sharing functionality.');
                return;
            }
            
            if (!navigator.mediaDevices || !navigator.mediaDevices.getDisplayMedia) {
                alert('Screen sharing is not supported in this browser. Please use Chrome, Firefox, Safari, or Edge.');
                return;
            }
            
            if (isScreenSharing) {
                await stopScreenShare();
            } else {
                await startScreenShare();
            }
        }
        
        function switchSharingMode(mode) {
            // Only screen mode is supported now
            console.log('Screen sharing mode selected');
        }
        
        async function shareEntireScreen() {
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: { 
                        mediaSource: 'screen',
                        width: { ideal: 1920, max: 1920 },
                        height: { ideal: 1080, max: 1080 },
                        frameRate: { ideal: 30, max: 30 }
                    },
                    audio: true
                });
                showScreenPreview();
            } catch (error) {
                console.error('Error sharing screen:', error);
                alert('Failed to share screen. Please try again.');
            }
        }
        
        
        function showScreenPreview() {
            if (screenStream) {
                screenPreview.srcObject = screenStream;
                screenPreview.style.display = 'block';
            }
        }
        
        async function startScreenShare() {
            try {
                if (!screenStream) {
                    await shareEntireScreen();
                }
                
                if (!screenStream) {
                    throw new Error('No screen stream available');
                }
                
                // Get the video track to share
                const videoTrack = screenStream.getVideoTracks()[0];
                if (!videoTrack) {
                    throw new Error('No video track available in screen stream');
                }
                
                console.log('Sharing video track:', videoTrack.label, 'Ready state:', videoTrack.readyState);
                
                // Replace video track in all peer connections
                const replacePromises = Object.values(peerConnections).map(async (pc) => {
                    try {
                        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender) {
                            await sender.replaceTrack(videoTrack);
                            console.log('Replaced track in peer connection');
                        } else {
                            // Add new track if no video sender exists
                            pc.addTrack(videoTrack, screenStream);
                            console.log('Added new track to peer connection');
                        }
                    } catch (error) {
                        console.error('Error updating peer connection:', error);
                    }
                });
                
                await Promise.all(replacePromises);
                
                // Update local stream
                if (localStream) {
                    // Remove existing video track
                    const existingVideoTrack = localStream.getVideoTracks()[0];
                    if (existingVideoTrack) {
                        localStream.removeTrack(existingVideoTrack);
                    }
                    // Add new video track
                    localStream.addTrack(videoTrack);
                } else {
                    localStream = new MediaStream([videoTrack]);
                    // Add audio track if we have one
                    if (localStream.getAudioTracks().length === 0) {
                        try {
                            const audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            const audioTrack = audioStream.getAudioTracks()[0];
                            localStream.addTrack(audioTrack);
                        } catch (error) {
                            console.warn('Could not get audio track:', error);
                        }
                    }
                }
                
                // Update local video element
                createLocalVideoElement();
                
                // Handle screen sharing audio if available
                const audioTrack = screenStream.getAudioTracks()[0];
                if (audioTrack) {
                    console.log('Screen audio available but not sharing to avoid feedback');
                }
                
                isScreenSharing = true;
                screenBtn.classList.add('active');
                screenIcon.textContent = 'ðŸ”´';
                document.getElementById('startShareBtn').style.display = 'none';
                document.getElementById('stopShareBtn').style.display = 'inline-block';
                
                console.log('Screen sharing started successfully');
            } catch (error) {
                console.error('Error starting screen share:', error);
                alert('Failed to start screen sharing: ' + error.message);
            }
        }
        
        async function stopScreenShare() {
            try {
                // Stop screen stream
                if (screenStream) {
                    screenStream.getTracks().forEach(track => track.stop());
                    screenStream = null;
                }
                
                // Get webcam stream back if we had video enabled
                if (isVideoEnabled && !isVideoMuted) {
                    try {
                        const newStream = await navigator.mediaDevices.getUserMedia({ 
                            video: {
                                width: { ideal: 1280, max: 1280 },
                                height: { ideal: 720, max: 720 },
                                frameRate: { ideal: 30, max: 30 }
                            }
                        });
                        
                        const videoTrack = newStream.getVideoTracks()[0];
                        if (videoTrack) {
                            // Replace track in all peer connections
                            const replacePromises = Object.values(peerConnections).map(async (pc) => {
                                const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                                if (sender) {
                                    await sender.replaceTrack(videoTrack);
                                }
                            });
                            
                            await Promise.all(replacePromises);
                            
                            // Update local stream
                            if (localStream && localStream.getVideoTracks().length > 0) {
                                localStream.removeTrack(localStream.getVideoTracks()[0]);
                            }
                            localStream.addTrack(videoTrack);
                            
                            createLocalVideoElement();
                        }
                    } catch (error) {
                        console.error('Error restoring webcam:', error);
                    }
                } else {
                    // Remove video track from all connections
                    const removePromises = Object.values(peerConnections).map(async (pc) => {
                        const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                        if (sender) {
                            await sender.replaceTrack(null);
                        }
                    });
                    
                    await Promise.all(removePromises);
                    
                    if (localStream && localStream.getVideoTracks().length > 0) {
                        localStream.removeTrack(localStream.getVideoTracks()[0]);
                    }
                    
                    createLocalVideoElement();
                }
                
                isScreenSharing = false;
                screenBtn.classList.remove('active');
                screenIcon.textContent = 'ðŸ–¥ï¸';
                document.getElementById('startShareBtn').style.display = 'inline-block';
                document.getElementById('stopShareBtn').style.display = 'none';
                screenPreview.style.display = 'none';
                
                console.log('Screen sharing stopped successfully');
            } catch (error) {
                console.error('Error stopping screen share:', error);
            }
        }
        
        // Voice recording functions
        async function toggleVoiceRecording() {
            if (!isRecordingVoice) {
                await startVoiceRecording();
            } else {
                await stopVoiceRecording();
            }
        }
        
        async function startVoiceRecording() {
            try {
                // Request microphone permission
                voiceRecordingStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        sampleRate: 44100
                    }
                });
                
                // Create MediaRecorder
                const options = {
                    mimeType: 'audio/webm;codecs=opus'
                };
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/webm';
                }
                
                if (!MediaRecorder.isTypeSupported(options.mimeType)) {
                    options.mimeType = 'audio/mp4';
                }
                
                voiceMediaRecorder = new MediaRecorder(voiceRecordingStream, options);
                voiceAudioChunks = [];
                
                voiceMediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        voiceAudioChunks.push(event.data);
                    }
                };
                
                voiceMediaRecorder.onstop = async () => {
                    const audioBlob = new Blob(voiceAudioChunks, { type: voiceMediaRecorder.mimeType });
                    await sendVoiceMessage(audioBlob);
                };
                
                // Start recording
                voiceMediaRecorder.start(1000); // Collect data every second
                isRecordingVoice = true;
                voiceRecordingStartTime = Date.now();
                
                // Update UI
                const recordBtn = document.getElementById('voiceRecordBtn');
                recordBtn.classList.add('recording');
                recordBtn.innerHTML = 'â¹ï¸';
                
                // Show recording indicator
                const recordingIndicator = document.getElementById('recordingIndicator');
                recordingIndicator.classList.remove('hidden');
                
                // Start timer
                startRecordingTimer();
                
            } catch (error) {
                console.error('Error starting voice recording:', error);
                alert('Could not access microphone. Please check permissions.');
                resetVoiceRecording();
            }
        }
        
        async function stopVoiceRecording() {
            if (voiceMediaRecorder && isRecordingVoice) {
                voiceMediaRecorder.stop();
                stopRecordingTimer();
                cleanupVoiceRecording();
                hideRecordingIndicator();
            }
        }
        
        function cancelVoiceRecording() {
            if (voiceMediaRecorder && isRecordingVoice) {
                voiceMediaRecorder.stop();
                voiceAudioChunks = []; // Clear chunks to prevent sending
                stopRecordingTimer();
                cleanupVoiceRecording();
                hideRecordingIndicator();
            }
        }
        
        function cleanupVoiceRecording() {
            isRecordingVoice = false;
            
            // Stop all tracks
            if (voiceRecordingStream) {
                voiceRecordingStream.getTracks().forEach(track => track.stop());
                voiceRecordingStream = null;
            }
            
            // Reset UI
            const recordBtn = document.getElementById('voiceRecordBtn');
            recordBtn.classList.remove('recording');
            recordBtn.innerHTML = 'ðŸŽ¤';
        }
        
        function resetVoiceRecording() {
            cleanupVoiceRecording();
            hideRecordingIndicator();
            voiceAudioChunks = [];
        }
        
        function startRecordingTimer() {
            voiceRecordingTimer = setInterval(() => {
                const elapsed = Date.now() - voiceRecordingStartTime;
                const seconds = Math.floor(elapsed / 1000);
                const minutes = Math.floor(seconds / 60);
                const displaySeconds = seconds % 60;
                
                const timeString = `${minutes.toString().padStart(2, '0')}:${displaySeconds.toString().padStart(2, '0')}`;
                document.getElementById('recordingTime').textContent = timeString;
                
                // Auto-stop after 5 minutes
                if (seconds >= 300) {
                    stopVoiceRecording();
                }
            }, 1000);
        }
        
        function stopRecordingTimer() {
            if (voiceRecordingTimer) {
                clearInterval(voiceRecordingTimer);
                voiceRecordingTimer = null;
            }
        }
        
        function hideRecordingIndicator() {
            const recordingIndicator = document.getElementById('recordingIndicator');
            recordingIndicator.classList.add('hidden');
            document.getElementById('recordingTime').textContent = '00:00';
        }
        
        async function sendVoiceMessage(audioBlob) {
            if (voiceAudioChunks.length === 0) return; // Cancelled recording
            
            try {
                // Create form data
                const formData = new FormData();
                const timestamp = Date.now();
                const fileName = `voice_${timestamp}.webm`;
                
                formData.append('voice', audioBlob, fileName);
                formData.append('room_id', roomId);
                formData.append('duration', Math.floor((Date.now() - voiceRecordingStartTime) / 1000));
                
                // Show upload progress
                const uploadProgress = document.getElementById('uploadProgress');
                const progressText = document.getElementById('progressText');
                uploadProgress.classList.remove('hidden');
                progressText.textContent = 'Sending voice message...';
                
                // Send to server
                const response = await fetch('/upload_voice', {
                    method: 'POST',
                    body: formData
                });
                
                const result = await response.json();
                
                if (result.success) {
                    // Send voice message via socket
                    socket.emit('send_voice_message', {
                        voice_info: result.voice_info
                    });
                    
                    progressText.textContent = 'Voice message sent!';
                    setTimeout(() => {
                        uploadProgress.classList.add('hidden');
                    }, 2000);
                } else {
                    alert('Failed to send voice message: ' + result.error);
                    uploadProgress.classList.add('hidden');
                }
                
            } catch (error) {
                console.error('Error sending voice message:', error);
                alert('Failed to send voice message');
                document.getElementById('uploadProgress').classList.add('hidden');
            }
        }
        
        function playVoiceMessage(voiceUrl, button, progressBar, durationText) {
            // Stop any currently playing voice
            if (currentPlayingVoice && !currentPlayingVoice.paused) {
                currentPlayingVoice.pause();
                currentPlayingVoice.currentTime = 0;
                // Reset previous button
                document.querySelectorAll('.voice-play-btn.playing').forEach(btn => {
                    btn.classList.remove('playing');
                    btn.innerHTML = 'â–¶ï¸';
                });
            }
            
            // Create new audio element
            const audio = new Audio(voiceUrl);
            currentPlayingVoice = audio;
            
            button.classList.add('playing');
            button.innerHTML = 'â¸ï¸';
            
            audio.addEventListener('loadedmetadata', () => {
                const duration = Math.floor(audio.duration);
                const minutes = Math.floor(duration / 60);
                const seconds = duration % 60;
                durationText.textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;
            });
            
            audio.addEventListener('timeupdate', () => {
                const progress = (audio.currentTime / audio.duration) * 100;
                progressBar.style.width = `${progress}%`;
            });
            
            audio.addEventListener('ended', () => {
                button.classList.remove('playing');
                button.innerHTML = 'â–¶ï¸';
                progressBar.style.width = '0%';
                currentPlayingVoice = null;
            });
            
            audio.addEventListener('error', () => {
                button.classList.remove('playing');
                button.innerHTML = 'âŒ';
                alert('Error playing voice message');
                currentPlayingVoice = null;
            });
            
            // Toggle play/pause
            if (audio.paused) {
                audio.play().catch(error => {
                    console.error('Error playing audio:', error);
                    button.classList.remove('playing');
                    button.innerHTML = 'âŒ';
                    alert('Error playing voice message');
                });
            } else {
                audio.pause();
                button.classList.remove('playing');
                button.innerHTML = 'â–¶ï¸';
            }
        }
        
        // File sharing functions
        function triggerFileUpload() {
            document.getElementById('fileInput').click();
        }
        
        async function handleFileUpload(files) {
            if (!files || files.length === 0) return;
            
            const uploadProgress = document.getElementById('uploadProgress');
            const progressFill = document.getElementById('progressFill');
            const progressText = document.getElementById('progressText');
            
            for (let i = 0; i < files.length; i++) {
                const file = files[i];
                
                // Check file size (50MB limit)
                if (file.size > 50 * 1024 * 1024) {
                    alert(`File "${file.name}" is too large. Maximum size is 50MB.`);
                    continue;
                }
                
                // Show upload progress
                uploadProgress.classList.remove('hidden');
                progressFill.style.width = '0%';
                progressText.textContent = `Uploading ${file.name}... 0%`;
                
                const formData = new FormData();
                formData.append('file', file);
                formData.append('room_id', roomId);
                
                try {
                    const xhr = new XMLHttpRequest();
                    
                    // Track upload progress
                    xhr.upload.addEventListener('progress', (e) => {
                        if (e.lengthComputable) {
                            const percentComplete = Math.round((e.loaded / e.total) * 100);
                            progressFill.style.width = percentComplete + '%';
                            progressText.textContent = `Uploading ${file.name}... ${percentComplete}%`;
                        }
                    });
                    
                    xhr.onload = function() {
                        if (xhr.status === 200) {
                            const response = JSON.parse(xhr.responseText);
                            if (response.success) {
                                // Send file message via socket
                                socket.emit('send_file_message', {
                                    file_info: response.file_info
                                });
                                progressText.textContent = `${file.name} uploaded successfully!`;
                                setTimeout(() => {
                                    uploadProgress.classList.add('hidden');
                                }, 2000);
                            } else {
                                alert(`Failed to upload ${file.name}: ${response.error}`);
                                uploadProgress.classList.add('hidden');
                            }
                        } else {
                            alert(`Failed to upload ${file.name}. Server error.`);
                            uploadProgress.classList.add('hidden');
                        }
                    };
                    
                    xhr.onerror = function() {
                        alert(`Failed to upload ${file.name}. Network error.`);
                        uploadProgress.classList.add('hidden');
                    };
                    
                    xhr.open('POST', '/upload_file');
                    xhr.send(formData);
                    
                } catch (error) {
                    console.error('Upload error:', error);
                    alert(`Failed to upload ${file.name}: ${error.message}`);
                    uploadProgress.classList.add('hidden');
                }
            }
        }
        
        // File input change handler
        document.addEventListener('DOMContentLoaded', function() {
            const fileInput = document.getElementById('fileInput');
            if (fileInput) {
                fileInput.addEventListener('change', function(e) {
                    handleFileUpload(e.target.files);
                    // Clear the input so the same file can be uploaded again
                    e.target.value = '';
                });
            }
        });
        
        // Chat functions
        function displayMessage(message) {
            const messageDiv = document.createElement('div');
            
            if (message.type === 'system') {
                messageDiv.className = 'message system';
                messageDiv.innerHTML = `
                    <div class="message-content">${message.message}</div>
                `;
            } else if (message.type === 'file') {
                const isOwn = message.user_id === socket.id;
                messageDiv.className = `message ${isOwn ? 'own' : 'user'}`;
                const fileInfo = message.file_info;
                messageDiv.innerHTML = `
                    <div class="message-header">
                        ${message.username} â€¢ ${message.timestamp}
                    </div>
                    <div class="file-message">
                        <div class="file-info">
                            <div class="file-icon">${fileInfo.icon}</div>
                            <div class="file-details">
                                <div class="file-name">${escapeHtml(fileInfo.original_filename)}</div>
                                <div class="file-meta">${fileInfo.size_mb} MB â€¢ ${fileInfo.extension.toUpperCase()}</div>
                            </div>
                            <a href="${fileInfo.file_path}" download="${escapeHtml(fileInfo.original_filename)}">
                                <button class="file-download-btn">Download</button>
                            </a>
                        </div>
                    </div>
                `;
            } else if (message.type === 'voice') {
                const isOwn = message.user_id === socket.id;
                messageDiv.className = `message ${isOwn ? 'own' : 'user'}`;
                const voiceInfo = message.voice_info;
                const voiceId = 'voice_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
                
                messageDiv.innerHTML = `
                    <div class="message-header">
                        ${message.username} â€¢ ${message.timestamp}
                    </div>
                    <div class="voice-message">
                        <button class="voice-play-btn" id="play_${voiceId}" onclick="playVoiceMessage('${voiceInfo.voice_path}', this, document.getElementById('progress_${voiceId}'), document.getElementById('duration_${voiceId}'))">
                            â–¶ï¸
                        </button>
                        <div class="voice-waveform">
                            <div class="voice-progress" id="progress_${voiceId}"></div>
                        </div>
                        <div class="voice-duration" id="duration_${voiceId}">
                            ${Math.floor(voiceInfo.duration / 60)}:${(voiceInfo.duration % 60).toString().padStart(2, '0')}
                        </div>
                    </div>
                `;
            } else {
                const isOwn = message.user_id === socket.id;
                messageDiv.className = `message ${isOwn ? 'own' : 'user'}`;
                messageDiv.innerHTML = `
                    <div class="message-header">
                        ${message.username} â€¢ ${message.timestamp}
                    </div>
                    <div class="message-content">${escapeHtml(message.message)}</div>
                `;
            }
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }
        
        function sendMessage() {
            const message = chatInput.value.trim();
            if (message) {
                socket.emit('send_message', { message: message });
                chatInput.value = '';
                chatSendBtn.disabled = true;
                
                // Stop typing indicator
                if (isTyping) {
                    socket.emit('stop_typing');
                    isTyping = false;
                }
            }
        }
        
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }
        
        function updateTypingIndicator(data) {
            if (data.is_typing) {
                typingIndicator.textContent = `${data.username} is typing...`;
            } else {
                typingIndicator.textContent = '';
            }
        }
        
        // Chat input event handlers
        chatInput.addEventListener('input', () => {
            const hasText = chatInput.value.trim().length > 0;
            chatSendBtn.disabled = !hasText;
            
            // Handle typing indicator
            if (hasText && !isTyping) {
                isTyping = true;
                socket.emit('typing', { is_typing: true });
            }
            
            // Clear existing timer
            if (typingTimer) {
                clearTimeout(typingTimer);
            }
            
            // Set timer to stop typing indicator
            typingTimer = setTimeout(() => {
                if (isTyping) {
                    isTyping = false;
                    socket.emit('stop_typing');
                }
            }, 1000);
        });
        
        chatInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendMessage();
            }
        });
        
        chatInput.addEventListener('blur', () => {
            if (isTyping) {
                isTyping = false;
                socket.emit('stop_typing');
            }
        });
        
    // AI/ML implementation removed from client
        
        // Advanced Audio Processing Functions
        async function setupAdvancedAudioProcessing(inputStream) {
            try {
                console.log('Setting up advanced audio processing...');
                
                // Create new audio context for processing
                audioProcessingContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 48000,
                    latencyHint: 'interactive'
                });
                
                // Create source from input stream
                const audioTrack = inputStream.getAudioTracks()[0];
                if (!audioTrack) {
                    console.log('No audio track found for processing');
                    return;
                }
                
                sourceNode = audioProcessingContext.createMediaStreamSource(inputStream);
                
                // Create audio processing chain
                await createAudioProcessingChain();
                
                // Create processed stream
                destinationNode = audioProcessingContext.createMediaStreamDestination();
                
                // Connect the processing chain
                connectAudioProcessingChain();
                
                // Create new stream with processed audio and original video
                const processedAudioTrack = destinationNode.stream.getAudioTracks()[0];
                const videoTracks = inputStream.getVideoTracks();
                
                processedStream = new MediaStream();
                processedStream.addTrack(processedAudioTrack);
                videoTracks.forEach(track => processedStream.addTrack(track));
                
                // Setup noise level monitoring
                setupNoiseMonitoring();
                
                console.log('Advanced audio processing setup complete');
                
            } catch (error) {
                console.error('Error setting up audio processing:', error);
                processedStream = inputStream; // Fallback to original stream
            }
        }
        
        async function createAudioProcessingChain() {
            // Gain node for volume control
            gainNode = audioProcessingContext.createGain();
            gainNode.gain.value = currentGain;
            
            // High-pass filter to remove low-frequency noise (rumble, hum)
            highPassFilter = audioProcessingContext.createBiquadFilter();
            highPassFilter.type = 'highpass';
            highPassFilter.frequency.value = 100; // Remove frequencies below 100Hz
            highPassFilter.Q.value = 1;
            
            // Dynamic compressor for better speech clarity
            compressorNode = audioProcessingContext.createDynamicsCompressor();
            compressorNode.threshold.value = -24;
            compressorNode.knee.value = 30;
            compressorNode.ratio.value = 12;
            compressorNode.attack.value = 0.003;
            compressorNode.release.value = 0.25;
            
            // Noise gate using a custom script processor
            if (audioProcessingContext.createScriptProcessor) {
                noiseGateNode = audioProcessingContext.createScriptProcessor(4096, 1, 1);
            } else {
                // Fallback for newer browsers
                await audioProcessingContext.audioWorklet.addModule(
                    'data:text/javascript;base64,' + btoa(`
                        class NoiseGateProcessor extends AudioWorkletProcessor {
                            constructor() {
                                super();
                                this.threshold = 0.2;
                                this.port.onmessage = (e) => {
                                    if (e.data.type === 'threshold') {
                                        this.threshold = e.data.value;
                                    }
                                };
                            }
                            
                            process(inputs, outputs, parameters) {
                                const input = inputs[0];
                                const output = outputs[0];
                                
                                if (input.length > 0) {
                                    const inputChannel = input[0];
                                    const outputChannel = output[0];
                                    
                                    for (let i = 0; i < inputChannel.length; i++) {
                                        const sample = inputChannel[i];
                                        const magnitude = Math.abs(sample);
                                        
                                        if (magnitude > this.threshold) {
                                            outputChannel[i] = sample;
                                        } else {
                                            outputChannel[i] = sample * 0.1; // Reduce but don't completely mute
                                        }
                                    }
                                }
                                
                                return true;
                            }
                        }
                        
                        registerProcessor('noise-gate', NoiseGateProcessor);
                    `)
                );
                noiseGateNode = new AudioWorkletNode(audioProcessingContext, 'noise-gate');
            }
            
            // Setup script processor fallback for noise gate
            if (noiseGateNode && noiseGateNode.onaudioprocess !== undefined) {
                noiseGateNode.onaudioprocess = function(audioProcessingEvent) {
                    const inputBuffer = audioProcessingEvent.inputBuffer;
                    const outputBuffer = audioProcessingEvent.outputBuffer;
                    
                    for (let channel = 0; channel < outputBuffer.numberOfChannels; channel++) {
                        const inputData = inputBuffer.getChannelData(channel);
                        const outputData = outputBuffer.getChannelData(channel);
                        
                        for (let sample = 0; sample < inputBuffer.length; sample++) {
                            const magnitude = Math.abs(inputData[sample]);
                            
                            if (magnitude > noiseGateThreshold) {
                                outputData[sample] = inputData[sample];
                            } else {
                                outputData[sample] = inputData[sample] * 0.1; // Reduce but don't completely mute
                            }
                        }
                    }
                };
            }
        }
        
        function connectAudioProcessingChain() {
            let currentNode = sourceNode;
            
            // Connect high-pass filter if enabled
            if (highPassFilterEnabled && highPassFilter) {
                currentNode.connect(highPassFilter);
                currentNode = highPassFilter;
            }
            
            // Connect compression if enabled
            if (compressionEnabled && compressorNode) {
                currentNode.connect(compressorNode);
                currentNode = compressorNode;
            }
            
            // Connect noise gate if enabled
            if (enhancedNoiseReduction && noiseGateNode) {
                currentNode.connect(noiseGateNode);
                currentNode = noiseGateNode;
            }
            
            // Connect gain control
            if (gainNode) {
                currentNode.connect(gainNode);
                currentNode = gainNode;
            }
            
            // Connect to destination
            if (destinationNode) {
                currentNode.connect(destinationNode);
            }
        }
        
        function setupNoiseMonitoring() {
            if (sourceNode && audioProcessingContext) {
                noiseAnalyser = audioProcessingContext.createAnalyser();
                noiseAnalyser.fftSize = 256;
                noiseAnalyser.smoothingTimeConstant = 0.8;
                
                sourceNode.connect(noiseAnalyser);
                
                const bufferLength = noiseAnalyser.frequencyBinCount;
                noiseDataArray = new Uint8Array(bufferLength);
                
                monitorNoiseLevel();
            }
        }
        
        function monitorNoiseLevel() {
            if (noiseAnalyser && noiseDataArray && isCallActive) {
                noiseAnalyser.getByteFrequencyData(noiseDataArray);
                
                // Calculate noise level (focus on lower frequencies which are typically noise)
                let noiseSum = 0;
                const lowFreqBins = Math.floor(noiseDataArray.length * 0.3); // Focus on lower 30% of frequencies
                
                for (let i = 0; i < lowFreqBins; i++) {
                    noiseSum += noiseDataArray[i];
                }
                
                const averageNoise = noiseSum / lowFreqBins;
                const noisePercentage = (averageNoise / 255) * 100;
                
                // Update noise level display
                if (noiseLevelFill && noiseLevelText) {
                    noiseLevelFill.style.width = noisePercentage + '%';
                    noiseLevelText.textContent = Math.round(noisePercentage) + '%';
                }
                
                requestAnimationFrame(monitorNoiseLevel);
            }
        }
        
        function cleanupAudioProcessing() {
            if (audioProcessingContext) {
                try {
                    audioProcessingContext.close();
                } catch (e) {
                    console.log('Error closing audio processing context:', e);
                }
                audioProcessingContext = null;
            }
            
            sourceNode = null;
            destinationNode = null;
            gainNode = null;
            highPassFilter = null;
            compressorNode = null;
            noiseGateNode = null;
            noiseAnalyser = null;
            noiseDataArray = null;
            processedStream = null;
        }
        
        // UI Control Functions for Noise Suppression
        function toggleEnhancedNoise() {
            enhancedNoiseReduction = !enhancedNoiseReduction;
            enhancedNoiseToggle.classList.toggle('active', enhancedNoiseReduction);
            
            if (audioProcessingContext && sourceNode && destinationNode) {
                // Disconnect and reconnect the processing chain
                try {
                    sourceNode.disconnect();
                    connectAudioProcessingChain();
                    console.log('Enhanced noise reduction:', enhancedNoiseReduction ? 'enabled' : 'disabled');
                } catch (e) {
                    console.error('Error toggling enhanced noise reduction:', e);
                }
            }
        }
        
        function toggleHighPassFilter() {
            highPassFilterEnabled = !highPassFilterEnabled;
            highPassToggle.classList.toggle('active', highPassFilterEnabled);
            
            if (audioProcessingContext && sourceNode && destinationNode) {
                try {
                    sourceNode.disconnect();
                    connectAudioProcessingChain();
                    console.log('High-pass filter:', highPassFilterEnabled ? 'enabled' : 'disabled');
                } catch (e) {
                    console.error('Error toggling high-pass filter:', e);
                }
            }
        }
        
        function toggleCompression() {
            compressionEnabled = !compressionEnabled;
            compressionToggle.classList.toggle('active', compressionEnabled);
            
            if (audioProcessingContext && sourceNode && destinationNode) {
                try {
                    sourceNode.disconnect();
                    connectAudioProcessingChain();
                    console.log('Dynamic compression:', compressionEnabled ? 'enabled' : 'disabled');
                } catch (e) {
                    console.error('Error toggling compression:', e);
                }
            }
        }
        
        function updateNoiseGate(value) {
            noiseGateThreshold = parseFloat(value) / 100; // Convert to 0-1 range
            
            // Update noise gate processor if using AudioWorkletNode
            if (noiseGateNode && noiseGateNode.port) {
                noiseGateNode.port.postMessage({
                    type: 'threshold',
                    value: noiseGateThreshold
                });
            }
            
            console.log('Noise gate threshold updated to:', noiseGateThreshold);
        }
        
        function updateGain(value) {
            currentGain = parseFloat(value);
            
            if (gainNode) {
                gainNode.gain.value = currentGain;
                console.log('Gain updated to:', currentGain);
            }
        }
        
        function captureNoiseProfile() {
            if (!noiseAnalyser || !noiseDataArray) {
                alert('Please start a call first to capture noise profile.');
                return;
            }
            
            console.log('Capturing noise profile...');
            
            // Capture current noise profile
            noiseAnalyser.getByteFrequencyData(noiseDataArray);
            noiseProfile = new Uint8Array(noiseDataArray);
            
            // Calculate average noise level for auto-adjustment
            let sum = 0;
            for (let i = 0; i < noiseProfile.length * 0.3; i++) { // Focus on lower frequencies
                sum += noiseProfile[i];
            }
            const averageNoise = sum / (noiseProfile.length * 0.3);
            
            // Auto-adjust noise gate threshold based on captured profile
            const recommendedThreshold = Math.min(0.8, Math.max(0.1, (averageNoise / 255) + 0.1));
            noiseGateThreshold = recommendedThreshold;
            
            // Update UI
            noiseGateSlider.value = recommendedThreshold * 100;
            
            // Update noise gate processor
            if (noiseGateNode && noiseGateNode.port) {
                noiseGateNode.port.postMessage({
                    type: 'threshold',
                    value: noiseGateThreshold
                });
            }
            
            alert(`Noise profile captured! Recommended threshold: ${Math.round(recommendedThreshold * 100)}%`);
            console.log('Noise profile captured, threshold set to:', recommendedThreshold);
        }
        
        // Advanced UI Control Functions
        function switchAudioTab(tabName) {
            // Remove active class from all tabs and content
            document.querySelectorAll('.audio-tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
            
            // Activate selected tab and content
            document.querySelector(`.audio-tab[onclick="switchAudioTab('${tabName}')"]`).classList.add('active');
            document.getElementById(tabName + 'Tab').classList.add('active');
            
            // Initialize visualizer if switching to analysis tab
            if (tabName === 'analysis') {
                setupVisualizer();
            }
        }
        
        function toggleVoiceIsolation() {
            voiceIsolationEnabled = !voiceIsolationEnabled;
            voiceIsolationToggle.classList.toggle('active', voiceIsolationEnabled);
            
            if (voiceIsolationEnabled) {
                // Voice isolation focuses on speech frequencies (300Hz-3400Hz)
                if (highPassFilter) {
                    highPassFilter.frequency.value = 300;
                    highPassFilter.Q.value = 2;
                }
                
                // Automatically enable compression for better voice clarity
                if (!compressionEnabled) {
                    toggleCompression();
                }
            } else {
                // Reset to normal high-pass filter settings
                if (highPassFilter) {
                    highPassFilter.frequency.value = 100;
                    highPassFilter.Q.value = 1;
                }
            }
            
            console.log('Voice isolation:', voiceIsolationEnabled ? 'enabled' : 'disabled');
        }
        
        function updateEQ(frequency, gain) {
            const freq = parseInt(frequency);
            const gainValue = parseFloat(gain);
            
            if (eqFilters[freq]) {
                eqFilters[freq].gain.value = gainValue;
                console.log(`EQ ${freq}Hz set to ${gainValue}dB`);
            }
        }
        
        function applyEQPreset(presetName) {
            // Remove active class from all preset buttons
            document.querySelectorAll('.preset-btn').forEach(btn => btn.classList.remove('active'));
            
            // Add active class to clicked button
            document.querySelector(`[onclick="applyEQPreset('${presetName}')"]`).classList.add('active');
            
            const presets = {
                'flat': { 60: 0, 170: 0, 310: 0, 600: 0, 1000: 0, 3000: 0, 6000: 0, 12000: 0 },
                'vocal': { 60: -2, 170: -1, 310: 0, 600: 1, 1000: 2, 3000: 3, 6000: 2, 12000: 1 },
                'broadcast': { 60: -3, 170: -2, 310: 0, 600: 2, 1000: 3, 3000: 4, 6000: 3, 12000: 1 },
                'bass-cut': { 60: -6, 170: -4, 310: -2, 600: 0, 1000: 0, 3000: 0, 6000: 0, 12000: 0 },
                'presence': { 60: -1, 170: 0, 310: 1, 600: 2, 1000: 3, 3000: 4, 6000: 3, 12000: 2 }
            };
            
            const preset = presets[presetName];
            if (preset) {
                Object.keys(preset).forEach(freq => {
                    const frequency = parseInt(freq);
                    const gain = preset[freq];
                    
                    // Update EQ filter
                    if (eqFilters[frequency]) {
                        eqFilters[frequency].gain.value = gain;
                    }
                    
                    // Update UI slider
                    const slider = document.getElementById(`eq${frequency}`);
                    if (slider) {
                        slider.value = gain;
                    }
                });
                
                console.log(`Applied EQ preset: ${presetName}`);
            }
        }
        
        function toggleEffect(effectName) {
            const effectBtn = document.getElementById(effectName + 'Btn');
            
            if (activeEffects.has(effectName)) {
                activeEffects.delete(effectName);
                effectBtn.classList.remove('active');
            } else {
                // For pitch effects, ensure only one is active at a time
                if (effectName === 'pitchUp' || effectName === 'pitchDown') {
                    activeEffects.delete('pitchUp');
                    activeEffects.delete('pitchDown');
                    document.getElementById('pitchUpBtn').classList.remove('active');
                    document.getElementById('pitchDownBtn').classList.remove('active');
                }
                
                activeEffects.add(effectName);
                effectBtn.classList.add('active');
            }
            
            // Reconnect audio chain with new effects
            if (audioProcessingContext && sourceNode && destinationNode) {
                try {
                    sourceNode.disconnect();
                    connectAudioProcessingChain();
                    console.log(`Effect ${effectName}:`, activeEffects.has(effectName) ? 'enabled' : 'disabled');
                } catch (e) {
                    console.error(`Error toggling effect ${effectName}:`, e);
                }
            }
        }
        
        function updateEffectIntensity(value) {
            effectIntensity = parseFloat(value) / 100;
            
            // Reconnect audio chain with new intensity
            if (audioProcessingContext && sourceNode && destinationNode && activeEffects.size > 0) {
                try {
                    sourceNode.disconnect();
                    connectAudioProcessingChain();
                    console.log('Effect intensity updated to:', effectIntensity);
                } catch (e) {
                    console.error('Error updating effect intensity:', e);
                }
            }
        }
        
        function setupVisualizer() {
            if (!visualizerCanvas) {
                visualizerCanvas = document.getElementById('audioVisualizer');
            }
            
            if (visualizerCanvas && audioProcessingContext) {
                visualizerContext = visualizerCanvas.getContext('2d');
                visualizerCanvas.width = visualizerCanvas.offsetWidth * 2; // High DPI
                visualizerCanvas.height = visualizerCanvas.offsetHeight * 2;
                visualizerCanvas.style.width = visualizerCanvas.offsetWidth + 'px';
                visualizerCanvas.style.height = visualizerCanvas.offsetHeight + 'px';
                visualizerContext.scale(2, 2);
                
                if (!frequencyAnalyser && sourceNode) {
                    frequencyAnalyser = audioProcessingContext.createAnalyser();
                    frequencyAnalyser.fftSize = 2048;
                    frequencyAnalyser.smoothingTimeConstant = 0.8;
                    frequencyDataArray = new Uint8Array(frequencyAnalyser.frequencyBinCount);
                    
                    sourceNode.connect(frequencyAnalyser);
                }
                
                if (!animationFrame) {
                    visualizeAudio();
                }
            }
        }
        
        function visualizeAudio() {
            if (!frequencyAnalyser || !visualizerContext || !isCallActive) {
                animationFrame = null;
                return;
            }
            
            animationFrame = requestAnimationFrame(visualizeAudio);
            
            frequencyAnalyser.getByteFrequencyData(frequencyDataArray);
            
            const width = visualizerCanvas.width / 2;
            const height = visualizerCanvas.height / 2;
            const barWidth = width / (frequencyDataArray.length / 4); // Show first quarter of frequencies
            
            visualizerContext.clearRect(0, 0, width, height);
            
            // Create gradient
            const gradient = visualizerContext.createLinearGradient(0, height, 0, 0);
            gradient.addColorStop(0, '#4CAF50');
            gradient.addColorStop(0.3, '#8BC34A');
            gradient.addColorStop(0.6, '#CDDC39');
            gradient.addColorStop(1, '#FFC107');
            
            let x = 0;
            for (let i = 0; i < frequencyDataArray.length / 4; i++) {
                const barHeight = (frequencyDataArray[i] / 255) * height * 0.8;
                
                visualizerContext.fillStyle = gradient;
                visualizerContext.fillRect(x, height - barHeight, barWidth - 1, barHeight);
                
                x += barWidth;
            }
            
            // Update audio meters in analysis tab
            updateAdvancedMeters();
        }
        
        function updateAdvancedMeters() {
            if (!frequencyDataArray) return;
            
            // Calculate volume level (RMS)
            let sum = 0;
            for (let i = 0; i < frequencyDataArray.length; i++) {
                const normalized = frequencyDataArray[i] / 255;
                sum += normalized * normalized;
            }
            const rms = Math.sqrt(sum / frequencyDataArray.length);
            const volumeLevel = Math.min(rms * 200, 100); // Scale and cap at 100%
            
            if (volumeMeter && volumeText) {
                volumeMeter.style.width = volumeLevel + '%';
                volumeText.textContent = Math.round(volumeLevel) + '%';
            }
            
            // Calculate dominant frequency (pitch detection)
            let maxIndex = 0;
            let maxValue = 0;
            for (let i = 20; i < frequencyDataArray.length / 2; i++) { // Skip very low frequencies
                if (frequencyDataArray[i] > maxValue) {
                    maxValue = frequencyDataArray[i];
                    maxIndex = i;
                }
            }
            
            const nyquist = audioProcessingContext.sampleRate / 2;
            const frequency = maxIndex * nyquist / frequencyDataArray.length;
            const pitchLevel = Math.min((frequency / 2000) * 100, 100); // Scale relative to 2kHz
            
            if (pitchMeter && pitchText) {
                pitchMeter.style.width = pitchLevel + '%';
                pitchText.textContent = Math.round(frequency) + 'Hz';
            }
            
            // Calculate spectral clarity (high-frequency content ratio)
            const midIndex = Math.floor(frequencyDataArray.length * 0.3);
            const highIndex = Math.floor(frequencyDataArray.length * 0.8);
            
            let midSum = 0, highSum = 0;
            for (let i = midIndex; i < highIndex; i++) {
                midSum += frequencyDataArray[i];
            }
            for (let i = highIndex; i < frequencyDataArray.length; i++) {
                highSum += frequencyDataArray[i];
            }
            
            const clarityRatio = midSum > 0 ? (highSum / midSum) : 0;
            const clarityLevel = Math.min(clarityRatio * 50, 100);
            
            if (clarityMeter && clarityText) {
                clarityMeter.style.width = clarityLevel + '%';
                clarityText.textContent = Math.round(clarityLevel) + '%';
            }
        }
        
        // Adaptive Bitrate and Resolution Scaling Functions
        function startAdaptiveQualityMonitoring() {
            if (!adaptiveQualityEnabled) return;
            
            console.log('Starting adaptive quality monitoring with GCC');
            updateQualityIndicator();
            
            // Initialize GCC controller with current quality settings
            const currentQuality = qualityLevels[currentQualityLevel];
            gccController.currentBitrate = currentQuality.bitrate;
            gccController.targetBitrate = currentQuality.bitrate;
            gccController.maxBitrate = Math.max(currentQuality.bitrate * 2, 2000000);
            gccController.minBitrate = Math.min(currentQuality.bitrate * 0.3, 100000);
            
            // Monitor network stats every 1 second for GCC
            statsInterval = setInterval(collectNetworkStats, 1000);
            
            // Check for quality adjustments every 5 seconds (less frequent than GCC bitrate adjustments)
            qualityAdjustmentTimer = setInterval(checkQualityAdjustment, 5000);
            
            // Initialize GCC display
            updateGCCDisplay();
        }
        
        function stopAdaptiveQualityMonitoring() {
            console.log('Stopping adaptive quality monitoring');
            
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            
            if (qualityAdjustmentTimer) {
                clearInterval(qualityAdjustmentTimer);
                qualityAdjustmentTimer = null;
            }
        }
        
        function startStatsCollection(userId, peerConnection) {
            // Store reference for stats collection
            peerConnection._userId = userId;
            
            // Start collecting stats immediately
            setTimeout(() => collectPeerStats(peerConnection), 1000);
        }
        
        async function collectPeerStats(peerConnection) {
            if (!peerConnection || peerConnection.connectionState !== 'connected') return;
            
            try {
                const stats = await peerConnection.getStats();
                const videoStats = {};
                const audioStats = {};
                const candidateStats = {};
                
                stats.forEach(report => {
                    if (report.type === 'inbound-rtp' && report.kind === 'video') {
                        videoStats.packetsLost = report.packetsLost || 0;
                        videoStats.packetsReceived = report.packetsReceived || 0;
                        videoStats.jitter = report.jitter || 0;
                        videoStats.bytesReceived = report.bytesReceived || 0;
                        videoStats.framesDecoded = report.framesDecoded || 0;
                        videoStats.framesDropped = report.framesDropped || 0;
                        videoStats.timestamp = report.timestamp;
                        
                        // Simulcast layer info
                        if (report.rid) {
                            videoStats.rid = report.rid;
                            videoStats.layerBytesReceived = report.bytesReceived || 0;
                        }
                    }
                    
                    if (report.type === 'outbound-rtp' && report.kind === 'video') {
                        videoStats.packetsSent = report.packetsSent || 0;
                        videoStats.bytesSent = report.bytesSent || 0;
                        videoStats.retransmittedPacketsSent = report.retransmittedPacketsSent || 0;
                        videoStats.framesSent = report.framesSent || 0;
                        videoStats.timestamp = report.timestamp;
                        videoStats.targetBitrate = report.targetBitrate || 0;
                        videoStats.encoderImplementation = report.encoderImplementation || '';
                        
                        // Simulcast layer info
                        if (report.rid) {
                            if (!videoStats.layers) videoStats.layers = {};
                            videoStats.layers[report.rid] = {
                                bytesSent: report.bytesSent || 0,
                                packetsSent: report.packetsSent || 0,
                                framesSent: report.framesSent || 0,
                                targetBitrate: report.targetBitrate || 0
                            };
                        }
                    }
                    
                    if (report.type === 'candidate-pair' && report.state === 'succeeded') {
                        candidateStats.currentRoundTripTime = report.currentRoundTripTime || 0;
                        candidateStats.availableOutgoingBitrate = report.availableOutgoingBitrate || 0;
                        candidateStats.availableIncomingBitrate = report.availableIncomingBitrate || 0;
                        candidateStats.totalRoundTripTime = report.totalRoundTripTime || 0;
                        candidateStats.responsesReceived = report.responsesReceived || 0;
                        candidateStats.bytesSent = report.bytesSent || 0;
                        candidateStats.bytesReceived = report.bytesReceived || 0;
                        candidateStats.timestamp = report.timestamp;
                    }
                    
                    if (report.type === 'remote-inbound-rtp' && report.kind === 'video') {
                        videoStats.remotePacketsLost = report.packetsLost || 0;
                        videoStats.remoteJitter = report.jitter || 0;
                        videoStats.roundTripTime = report.roundTripTime || 0;
                        videoStats.fractionLost = report.fractionLost || 0;
                    }
                });
                
                // Update global network stats and run GCC
                updateNetworkStats(videoStats, candidateStats);
                
                // Run Google Congestion Control algorithm
                if (gccEnabled) {
                    runGoogleCongestionControl(videoStats, candidateStats);
                }
                
                // Update simulcast layer stats if available
                if (simulcastEnabled && videoStats.layers) {
                    updateSimulcastLayerStats(peerConnection._userId, videoStats.layers);
                }
                
                // Schedule next collection
                setTimeout(() => collectPeerStats(peerConnection), 1000); // More frequent for GCC
                
            } catch (error) {
                console.error('Error collecting peer stats:', error);
            }
        }
        
        function collectNetworkStats() {
            // This will be called by the interval timer
            // Individual peer stats are collected separately
            updateNetworkDisplay();
        }
        
        function updateNetworkStats(videoStats, candidateStats) {
            const now = Date.now();
            
            if (videoStats.packetsReceived && videoStats.packetsLost !== undefined) {
                const totalPackets = videoStats.packetsReceived + videoStats.packetsLost;
                networkStats.packetsLost = totalPackets > 0 ? videoStats.packetsLost / totalPackets : 0;
            }
            
            if (videoStats.jitter !== undefined) {
                networkStats.jitter = videoStats.jitter * 1000; // Convert to milliseconds
            }
            
            if (candidateStats && candidateStats.currentRoundTripTime !== undefined) {
                networkStats.rtt = candidateStats.currentRoundTripTime * 1000; // Convert to milliseconds
            }
            
            if (candidateStats && candidateStats.availableOutgoingBitrate !== undefined) {
                networkStats.bandwidth = candidateStats.availableOutgoingBitrate;
            }
            
            // Store additional data for GCC
            if (videoStats.timestamp) {
                networkStats.sendTimeMs = videoStats.timestamp;
            }
            
            if (candidateStats && candidateStats.bytesSent !== undefined) {
                networkStats.totalBytes = candidateStats.bytesSent;
            }
            
            if (videoStats.packetsSent !== undefined) {
                networkStats.totalPackets = videoStats.packetsSent;
            }
            
            networkStats.timestamp = now;
        }
        
        function updateNetworkDisplay() {
            const rttElement = document.getElementById('rttValue');
            const lossElement = document.getElementById('lossValue');
            const jitterElement = document.getElementById('jitterValue');
            
            if (rttElement) rttElement.textContent = Math.round(networkStats.rtt);
            if (lossElement) lossElement.textContent = (networkStats.packetsLost * 100).toFixed(1);
            if (jitterElement) jitterElement.textContent = Math.round(networkStats.jitter);
        }
        
        function checkQualityAdjustment() {
            if (!adaptiveQualityEnabled || !isCallActive) return;
            
            const now = Date.now();
            if (now - lastQualityAdjustment < adaptiveQualitySettings.adjustmentCooldown) {
                return; // Still in cooldown period
            }
            
            const isNetworkBad = (
                networkStats.packetsLost > adaptiveQualitySettings.packetLossThreshold ||
                networkStats.rtt > adaptiveQualitySettings.rttThreshold ||
                networkStats.jitter > adaptiveQualitySettings.jitterThreshold
            );
            
            if (isNetworkBad) {
                consecutiveBadNetworkSamples++;
                consecutiveGoodNetworkSamples = 0;
                
                if (consecutiveBadNetworkSamples >= adaptiveQualitySettings.badNetworkThreshold) {
                    if (currentQualityLevel > 0) {
                        adjustQuality(currentQualityLevel - 1);
                        console.log('Network degraded, reducing quality to level', currentQualityLevel);
                    }
                    consecutiveBadNetworkSamples = 0;
                }
            } else {
                consecutiveGoodNetworkSamples++;
                consecutiveBadNetworkSamples = 0;
                
                if (consecutiveGoodNetworkSamples >= adaptiveQualitySettings.goodNetworkThreshold) {
                    if (currentQualityLevel < qualityLevels.length - 1) {
                        adjustQuality(currentQualityLevel + 1);
                        console.log('Network improved, increasing quality to level', currentQualityLevel);
                    }
                    consecutiveGoodNetworkSamples = 0;
                }
            }
        }
        
        async function adjustQuality(newQualityLevel) {
            if (newQualityLevel === currentQualityLevel || !isCallActive) return;
            
            const previousLevel = currentQualityLevel;
            currentQualityLevel = Math.max(0, Math.min(qualityLevels.length - 1, newQualityLevel));
            lastQualityAdjustment = Date.now();
            
            console.log(`Adjusting quality from level ${previousLevel} to ${currentQualityLevel}`);
            
            try {
                // Apply new constraints to local video track
                const videoTrack = localStream ? localStream.getVideoTracks()[0] : null;
                if (videoTrack) {
                    const quality = qualityLevels[currentQualityLevel];
                    const constraints = {
                        width: quality.width,
                        height: quality.height,
                        frameRate: quality.frameRate
                    };
                    
                    await videoTrack.applyConstraints(constraints);
                    console.log('Applied new video constraints:', constraints);
                }
                
                // Update GCC controller limits based on new quality level
                if (gccEnabled) {
                    const quality = qualityLevels[currentQualityLevel];
                    gccController.maxBitrate = Math.max(quality.bitrate * 1.5, 2000000);
                    gccController.minBitrate = Math.min(quality.bitrate * 0.5, 100000);
                    
                    // Adjust current target if it's outside new bounds
                    gccController.targetBitrate = Math.max(
                        gccController.minBitrate,
                        Math.min(gccController.maxBitrate, gccController.targetBitrate)
                    );
                }
                
                // Update bitrate for all peer connections (either GCC or fixed)
                Object.entries(peerConnections).forEach(([userId, pc]) => {
                    const videoSender = pc.getSenders().find(sender => 
                        sender.track && sender.track.kind === 'video'
                    );
                    if (videoSender) {
                        if (gccEnabled) {
                            applyGCCBitrateConstraints(videoSender, gccController.currentBitrate);
                        } else {
                            applyBitrateConstraints(videoSender, currentQualityLevel);
                        }
                    }
                });
                
                // Update UI
                updateQualityIndicator();
                updateGCCDisplay();
                
                // Show quality change notification
                showQualityChangeNotification(previousLevel, currentQualityLevel);
                
            } catch (error) {
                console.error('Error adjusting quality:', error);
                currentQualityLevel = previousLevel; // Revert on error
            }
        }
        
        async function applyBitrateConstraints(sender, qualityLevel) {
            try {
                const quality = qualityLevels[qualityLevel];
                const params = sender.getParameters();
                
                if (params.encodings && params.encodings.length > 0) {
                    params.encodings[0].maxBitrate = quality.bitrate;
                    await sender.setParameters(params);
                    console.log(`Applied bitrate constraint: ${quality.bitrate} bps`);
                }
            } catch (error) {
                console.error('Error applying bitrate constraints:', error);
            }
        }
        
        function updateQualityIndicator() {
            // Update quality dots
            for (let i = 0; i < qualityLevels.length; i++) {
                const dot = document.getElementById(`quality${i}`);
                if (dot) {
                    dot.classList.toggle('active', i <= currentQualityLevel);
                }
            }
            
            // Update quality text
            const qualityText = document.getElementById('qualityText');
            if (qualityText) {
                const qualityNames = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
                qualityText.textContent = qualityNames[currentQualityLevel] || 'Unknown';
            }
        }
        
        function toggleAdaptiveQuality() {
            adaptiveQualityEnabled = !adaptiveQualityEnabled;
            const toggle = document.getElementById('adaptiveQualityToggle');
            
            if (toggle) {
                toggle.classList.toggle('active', adaptiveQualityEnabled);
            }
            
            if (adaptiveQualityEnabled && isCallActive) {
                startAdaptiveQualityMonitoring();
                console.log('Adaptive quality enabled');
            } else {
                stopAdaptiveQualityMonitoring();
                console.log('Adaptive quality disabled');
            }
        }
        
        function setManualQuality(level) {
            if (!adaptiveQualityEnabled) {
                adjustQuality(level);
            }
        }
        
        // Simulcast and SVC Implementation
        function initializeSimulcast() {
            console.log('Initializing simulcast with layers:', simulcastLayers);
            
            // Initialize layer tracking
            simulcastStats.activeLayers = new Set(['low', 'medium', 'high']);
            simulcastStats.layerBytesSent = { low: 0, medium: 0, high: 0 };
            
            // Initialize seamless switching for existing participants
            participants.forEach((_, userId) => {
                currentReceiveLayers.set(userId, 'medium'); // Start with medium quality
            });
            
            // Update UI
            updateSimulcastDisplay();
            
            console.log('Simulcast initialized successfully with seamless switching enabled');
        }
        
        async function configureSimulcastEncodings(sender, userId) {
            try {
                const params = sender.getParameters();
                
                if (!params.encodings || params.encodings.length === 0) {
                    // Configure multiple encodings for simulcast
                    params.encodings = simulcastLayers.map(layer => ({
                        rid: layer.rid,
                        maxBitrate: layer.bitrate,
                        maxFramerate: layer.frameRate,
                        scaleResolutionDownBy: layer.rid === 'low' ? 4 : layer.rid === 'medium' ? 2 : 1,
                        scalabilityMode: svcEnabled ? layer.scalabilityMode : undefined,
                        active: simulcastStats.activeLayers.has(layer.rid)
                    }));
                } else {
                    // Update existing encodings
                    params.encodings.forEach((encoding, index) => {
                        if (index < simulcastLayers.length) {
                            const layer = simulcastLayers[index];
                            encoding.maxBitrate = layer.bitrate;
                            encoding.maxFramerate = layer.frameRate;
                            encoding.active = simulcastStats.activeLayers.has(layer.rid);
                            if (svcEnabled) {
                                encoding.scalabilityMode = layer.scalabilityMode;
                            }
                        }
                    });
                }
                
                await sender.setParameters(params);
                console.log(`Configured simulcast for user ${userId}:`, params.encodings);
                
                // Track this connection's layers
                currentSimulcastLayers.set(userId, params.encodings.map(e => e.rid));
                
            } catch (error) {
                console.error('Error configuring simulcast encodings:', error);
            }
        }
        
        function handleIncomingSimulcastStream(userId, trackEvent, remoteStream) {
            console.log(`Handling incoming simulcast stream from ${userId}`);
            
            const track = trackEvent.track;
            const receiver = trackEvent.receiver;
            
            // Get available layers from the receiver
            if (receiver.getParameters) {
                const params = receiver.getParameters();
                console.log(`Available layers from ${userId}:`, params);
            }
            
            // Select appropriate layer based on network conditions and preferences
            const preferredLayer = selectReceiveLayer(userId);
            
            // Create video element for this stream
            updateRemoteVideoElement(userId, remoteStream);
            
            // Request specific layer if supported
            if (receiver.getStats) {
                // Monitor stats for this receiver
                monitorReceiveLayerStats(userId, receiver);
            }
        }
        
        function selectReceiveLayer(userId) {
            // Check user preference first
            const userPreference = receiverPreferences.get(userId) || 'auto';
            
            if (userPreference !== 'auto') {
                return userPreference;
            }
            
            // Get current layer for hysteresis
            const currentLayer = currentReceiveLayers.get(userId) || 'medium';
            
            // Auto-select based on network conditions with hysteresis
            const estimatedBandwidth = gccController.bandwidthEstimator.estimatedBandwidth;
            const rtt = networkStats.rtt;
            const lossRate = networkStats.packetsLost;
            
            // Add hysteresis to prevent rapid switching
            const hysteresis = getLayerHysteresis(currentLayer);
            
            // Decision logic for layer selection with smoothing
            if (lossRate > (0.05 + hysteresis.loss) || 
                rtt > (500 + hysteresis.rtt) || 
                estimatedBandwidth < (200000 + hysteresis.bandwidth)) {
                return shouldSwitchToLower(currentLayer, 'low') ? 'low' : currentLayer;
            } else if (lossRate > (0.02 + hysteresis.loss * 0.5) || 
                       rtt > (200 + hysteresis.rtt * 0.5) || 
                       estimatedBandwidth < (600000 + hysteresis.bandwidth * 0.5)) {
                return shouldSwitchToLayer(currentLayer, 'medium') ? 'medium' : currentLayer;
            } else if (estimatedBandwidth > (1000000 - hysteresis.bandwidth) && 
                       rtt < (150 - hysteresis.rtt * 0.3) && 
                       lossRate < (0.01 - hysteresis.loss * 0.3)) {
                return shouldSwitchToHigher(currentLayer, 'high') ? 'high' : currentLayer;
            }
            
            return currentLayer;
        }
        
        function getLayerHysteresis(currentLayer) {
            // Add resistance to switching to prevent oscillation
            const baseHysteresis = {
                bandwidth: 50000,  // 50kbps buffer
                rtt: 20,           // 20ms buffer
                loss: 0.005        // 0.5% buffer
            };
            
            switch (currentLayer) {
                case 'low':
                    return {
                        bandwidth: baseHysteresis.bandwidth * 0.5, // Easier to switch up from low
                        rtt: baseHysteresis.rtt * 0.5,
                        loss: baseHysteresis.loss * 0.5
                    };
                case 'high':
                    return {
                        bandwidth: baseHysteresis.bandwidth * 1.5, // Harder to switch down from high
                        rtt: baseHysteresis.rtt * 1.5,
                        loss: baseHysteresis.loss * 1.5
                    };
                default:
                    return baseHysteresis;
            }
        }
        
        function shouldSwitchToLower(currentLayer, targetLayer) {
            const layerOrder = ['low', 'medium', 'high'];
            const currentIndex = layerOrder.indexOf(currentLayer);
            const targetIndex = layerOrder.indexOf(targetLayer);
            
            // Only switch down one level at a time for smoothness
            return targetIndex <= currentIndex && (currentIndex - targetIndex) <= 1;
        }
        
        function shouldSwitchToHigher(currentLayer, targetLayer) {
            const layerOrder = ['low', 'medium', 'high'];
            const currentIndex = layerOrder.indexOf(currentLayer);
            const targetIndex = layerOrder.indexOf(targetLayer);
            
            // Only switch up one level at a time for smoothness
            return targetIndex >= currentIndex && (targetIndex - currentIndex) <= 1;
        }
        
        function shouldSwitchToLayer(currentLayer, targetLayer) {
            // Always allow switching to medium layer (it's the stable middle ground)
            return true;
        }
        
        async function switchReceiveLayer(userId, targetLayer) {
            const peerConnection = peerConnections[userId];
            if (!peerConnection) return;
            
            // Check cooldown to prevent rapid switching
            const now = Date.now();
            const lastSwitch = layerSwitchCooldown.get(userId) || 0;
            if (now - lastSwitch < layerSwitchDelay) {
                console.log(`Layer switch cooldown active for ${userId}, skipping`);
                return;
            }
            
            const currentLayer = currentReceiveLayers.get(userId) || 'medium';
            if (currentLayer === targetLayer) {
                return; // Already on target layer
            }
            
            console.log(`Seamlessly switching from ${currentLayer} to ${targetLayer} for user ${userId}`);
            
            try {
                if (seamlessSwitching) {
                    await performSeamlessLayerSwitch(userId, currentLayer, targetLayer);
                } else {
                    await performStandardLayerSwitch(userId, targetLayer);
                }
                
                // Update tracking
                currentReceiveLayers.set(userId, targetLayer);
                layerSwitchCooldown.set(userId, now);
                
                // Update statistics
                simulcastStats.lastLayerSwitch = now;
                simulcastStats.switchCount++;
                
                // Track switch history
                if (!layerSwitchHistory.has(userId)) {
                    layerSwitchHistory.set(userId, []);
                }
                layerSwitchHistory.get(userId).push({
                    timestamp: now,
                    from: currentLayer,
                    to: targetLayer,
                    reason: 'network_adaptation'
                });
                
                console.log(`Successfully switched to ${targetLayer} layer for user ${userId}`);
                
            } catch (error) {
                console.error(`Error switching layer for user ${userId}:`, error);
            }
        }
        
        async function performSeamlessLayerSwitch(userId, fromLayer, toLayer) {
            const peerConnection = peerConnections[userId];
            const receivers = peerConnection.getReceivers();
            const videoReceiver = receivers.find(r => r.track && r.track.kind === 'video');
            
            if (!videoReceiver) return;
            
            // Start transition state
            transitionStates.set(userId, {
                active: true,
                fromLayer,
                toLayer,
                startTime: Date.now(),
                phase: 'preparing'
            });
            
            try {
                // Phase 1: Prepare new layer (buffer frames)
                await prepareLayerTransition(userId, videoReceiver, toLayer);
                
                // Phase 2: Perform the actual switch with minimal interruption
                await executeLayerSwitch(userId, videoReceiver, toLayer);
                
                // Phase 3: Cleanup and finalize
                finalizeLayerTransition(userId);
                
            } catch (error) {
                console.error('Seamless switch failed, falling back to standard switch:', error);
                await performStandardLayerSwitch(userId, toLayer);
            } finally {
                transitionStates.delete(userId);
            }
        }
        
        async function prepareLayerTransition(userId, videoReceiver, targetLayer) {
            const transition = transitionStates.get(userId);
            transition.phase = 'buffering';
            
            // Pre-buffer frames for the target layer
            return new Promise((resolve) => {
                let bufferCount = 0;
                const bufferInterval = setInterval(() => {
                    bufferCount++;
                    if (bufferCount >= bufferFrameCount) {
                        clearInterval(bufferInterval);
                        resolve();
                    }
                }, 16); // ~60fps buffering
                
                // Timeout after 100ms
                setTimeout(() => {
                    clearInterval(bufferInterval);
                    resolve();
                }, 100);
            });
        }
        
        async function executeLayerSwitch(userId, videoReceiver, targetLayer) {
            const transition = transitionStates.get(userId);
            transition.phase = 'switching';
            
            if (videoReceiver.getParameters) {
                const params = videoReceiver.getParameters();
                
                if (params.encodings) {
                    // Enable target layer, keep current layer active briefly for smooth transition
                    params.encodings.forEach(encoding => {
                        if (encoding.rid === targetLayer) {
                            encoding.active = true;
                        }
                    });
                    
                    await videoReceiver.setParameters(params);
                    
                    // Small delay to ensure new layer is receiving frames
                    await new Promise(resolve => setTimeout(resolve, 50));
                    
                    // Now disable other layers
                    params.encodings.forEach(encoding => {
                        encoding.active = encoding.rid === targetLayer;
                    });
                    
                    await videoReceiver.setParameters(params);
                }
            }
        }
        
        function finalizeLayerTransition(userId) {
            const transition = transitionStates.get(userId);
            transition.phase = 'complete';
            
            // Clear any buffered frames
            frameBuffers.delete(userId);
            
            // Update UI smoothly
            requestAnimationFrame(() => {
                updateSimulcastDisplay();
                updateVideoElementForLayerSwitch(userId);
            });
        }
        
        async function performStandardLayerSwitch(userId, targetLayer) {
            const peerConnection = peerConnections[userId];
            const receivers = peerConnection.getReceivers();
            const videoReceiver = receivers.find(r => r.track && r.track.kind === 'video');
            
            if (videoReceiver && videoReceiver.getParameters) {
                const params = videoReceiver.getParameters();
                
                if (params.encodings) {
                    params.encodings.forEach(encoding => {
                        encoding.active = encoding.rid === targetLayer;
                    });
                    
                    await videoReceiver.setParameters(params);
                }
            }
        }
        
        function updateVideoElementForLayerSwitch(userId) {
            const videoContainer = document.getElementById(`video-container-${userId}`);
            if (!videoContainer) return;
            
            const videoElement = videoContainer.querySelector('video');
            if (!videoElement) return;
            
            // Add smooth transition CSS
            videoElement.style.transition = 'opacity 0.1s ease-in-out';
            
            // Brief fade during layer switch to mask any artifacts
            videoElement.style.opacity = '0.95';
            setTimeout(() => {
                videoElement.style.opacity = '1';
            }, 100);
        }
        
        function monitorReceiveLayerStats(userId, receiver) {
            let consecutiveSwitchRequests = 0;
            let lastOptimalLayer = 'medium';
            
            const monitorInterval = setInterval(async () => {
                if (!isCallActive || !peerConnections[userId]) {
                    clearInterval(monitorInterval);
                    return;
                }
                
                try {
                    const stats = await receiver.getStats();
                    const layerStats = {};
                    
                    stats.forEach(report => {
                        if (report.type === 'inbound-rtp' && report.kind === 'video') {
                            const rid = report.rid || 'default';
                            layerStats[rid] = {
                                bytesReceived: report.bytesReceived || 0,
                                packetsReceived: report.packetsReceived || 0,
                                packetsLost: report.packetsLost || 0,
                                jitter: report.jitter || 0,
                                framesDecoded: report.framesDecoded || 0,
                                framesDropped: report.framesDropped || 0,
                                timestamp: report.timestamp
                            };
                        }
                    });
                    
                    // Update simulcast stats
                    updateSimulcastStats(userId, layerStats);
                    
                    // Check if layer switching is needed with smoothing
                    const currentLayer = getCurrentReceiveLayer(userId);
                    const optimalLayer = selectReceiveLayer(userId);
                    
                    if (optimalLayer === lastOptimalLayer) {
                        consecutiveSwitchRequests++;
                    } else {
                        consecutiveSwitchRequests = 1;
                        lastOptimalLayer = optimalLayer;
                    }
                    
                    // Only switch after consistent requests to avoid flickering
                    const switchThreshold = optimalLayer === 'low' ? 2 : 3; // Switch to low faster in bad conditions
                    
                    if (currentLayer !== optimalLayer && consecutiveSwitchRequests >= switchThreshold) {
                        await switchReceiveLayer(userId, optimalLayer);
                        consecutiveSwitchRequests = 0;
                    }
                    
                } catch (error) {
                    console.error(`Error monitoring layer stats for ${userId}:`, error);
                }
            }, 1000); // Check every second instead of every 2 seconds for better responsiveness
        }
        
        function getCurrentReceiveLayer(userId) {
            return currentReceiveLayers.get(userId) || 'medium';
        }
        
        function toggleSeamlessSwitching() {
            seamlessSwitching = !seamlessSwitching;
            console.log('Seamless switching:', seamlessSwitching ? 'enabled' : 'disabled');
            
            // Update UI if there's a toggle for it
            const toggle = document.getElementById('seamlessToggle');
            if (toggle) {
                toggle.classList.toggle('active', seamlessSwitching);
            }
            
            // Clear any active transitions when disabling
            if (!seamlessSwitching) {
                transitionStates.clear();
                frameBuffers.clear();
            }
        }
        
        function updateSimulcastStats(userId, layerStats) {
            // Update global simulcast statistics
            Object.entries(layerStats).forEach(([rid, stats]) => {
                if (!simulcastStats.layerBytesSent[rid]) {
                    simulcastStats.layerBytesSent[rid] = 0;
                }
                // Update bytes received for this layer
            });
            
            // Update UI
            updateSimulcastDisplay();
        }
        
        function updateSimulcastDisplay() {
            // Update active layers count
            const activeLayersElement = document.getElementById('activeLayers');
            if (activeLayersElement) {
                activeLayersElement.textContent = simulcastStats.activeLayers.size;
            }
            
            // Update layer switches count
            const layerSwitchesElement = document.getElementById('layerSwitches');
            if (layerSwitchesElement) {
                layerSwitchesElement.textContent = simulcastStats.switchCount;
            }
            
            // Update total bandwidth
            const totalBandwidthElement = document.getElementById('totalBandwidth');
            if (totalBandwidthElement) {
                const totalBitrate = Array.from(simulcastStats.activeLayers).reduce((sum, layer) => {
                    const layerInfo = simulcastLayers.find(l => l.rid === layer);
                    return sum + (layerInfo ? layerInfo.bitrate : 0);
                }, 0);
                totalBandwidthElement.textContent = (totalBitrate / 1000000).toFixed(2);
            }
            
            // Update layer indicators
            simulcastLayers.forEach(layer => {
                const indicator = document.getElementById(`layer-${layer.rid}`);
                if (indicator) {
                    indicator.classList.remove('active', 'disabled');
                    if (simulcastStats.activeLayers.has(layer.rid)) {
                        indicator.classList.add('active');
                    } else {
                        indicator.classList.add('disabled');
                    }
                }
            });
            
            // Update bandwidth distribution
            updateBandwidthDistribution();
        }
        
        function updateBandwidthDistribution() {
            const totalBitrate = simulcastLayers.reduce((sum, layer) => 
                simulcastStats.activeLayers.has(layer.rid) ? sum + layer.bitrate : sum, 0);
            
            if (totalBitrate > 0) {
                simulcastLayers.forEach(layer => {
                    const segment = document.getElementById(`bw-${layer.rid}`);
                    if (segment) {
                        const percentage = simulcastStats.activeLayers.has(layer.rid) 
                            ? (layer.bitrate / totalBitrate) * 100 
                            : 0;
                        segment.style.width = percentage + '%';
                    }
                });
            }
        }
        
        function toggleLayer(layerId) {
            if (simulcastStats.activeLayers.has(layerId)) {
                simulcastStats.activeLayers.delete(layerId);
            } else {
                simulcastStats.activeLayers.add(layerId);
            }
            
            console.log(`Toggled layer ${layerId}, active layers:`, Array.from(simulcastStats.activeLayers));
            
            // Update all peer connections with new layer configuration
            Object.entries(peerConnections).forEach(([userId, pc]) => {
                const videoSender = pc.getSenders().find(sender => 
                    sender.track && sender.track.kind === 'video'
                );
                if (videoSender) {
                    configureSimulcastEncodings(videoSender, userId);
                }
            });
            
            updateSimulcastDisplay();
        }
        
        function toggleSimulcast() {
            simulcastEnabled = !simulcastEnabled;
            const toggle = document.getElementById('simulcastToggle');
            
            if (toggle) {
                toggle.classList.toggle('active', simulcastEnabled);
            }
            
            console.log('Simulcast:', simulcastEnabled ? 'enabled' : 'disabled');
            
            if (!simulcastEnabled) {
                // Disable all layers except medium when simulcast is off
                simulcastStats.activeLayers.clear();
                simulcastStats.activeLayers.add('medium');
            } else {
                // Re-enable all layers when simulcast is on
                simulcastStats.activeLayers.clear();
                simulcastLayers.forEach(layer => simulcastStats.activeLayers.add(layer.rid));
            }
            
            updateSimulcastDisplay();
        }
        
        function toggleSVC() {
            svcEnabled = !svcEnabled;
            const toggle = document.getElementById('svcToggle');
            
            if (toggle) {
                toggle.classList.toggle('active', svcEnabled);
            }
            
            console.log('Scalable Video Coding:', svcEnabled ? 'enabled' : 'disabled');
            
            // Update all peer connections with new SVC configuration
            Object.entries(peerConnections).forEach(([userId, pc]) => {
                const videoSender = pc.getSenders().find(sender => 
                    sender.track && sender.track.kind === 'video'
                );
                if (videoSender) {
                    configureSimulcastEncodings(videoSender, userId);
                }
            });
        }
        
        function selectPreferredLayer(layer) {
            console.log('Selected preferred receive layer:', layer);
            
            // Update all receivers to use the preferred layer
            Object.entries(peerConnections).forEach(([userId, pc]) => {
                if (layer === 'auto') {
                    receiverPreferences.delete(userId);
                } else {
                    receiverPreferences.set(userId, layer);
                    switchReceiveLayer(userId, layer);
                }
            });
            
            // Update quality display
            const currentQualityElement = document.getElementById('currentQuality');
            if (currentQualityElement) {
                currentQualityElement.textContent = layer.charAt(0).toUpperCase() + layer.slice(1);
            }
        }
        
        // Google Congestion Control (GCC) Implementation
        function runGoogleCongestionControl(videoStats, candidateStats) {
            const now = Date.now();
            
            // Update bandwidth estimator
            updateBandwidthEstimator(candidateStats, now);
            
            // Run delay-based controller
            const delaySignal = runDelayBasedController(candidateStats, now);
            
            // Run loss-based controller
            const lossSignal = runLossBasedController(videoStats, now);
            
            // Combine signals and update target bitrate
            updateTargetBitrate(delaySignal, lossSignal, now);
            
            // Apply bitrate changes
            applyGCCBitrate();
            
            // Update UI
            updateGCCDisplay();
        }
        
        function updateBandwidthEstimator(candidateStats, timestamp) {
            const estimator = gccController.bandwidthEstimator;
            
            if (candidateStats && candidateStats.availableOutgoingBitrate) {
                const newEstimate = candidateStats.availableOutgoingBitrate;
                
                if (estimator.estimatedBandwidth === 0) {
                    estimator.estimatedBandwidth = newEstimate;
                    estimator.confidence = 0.5;
                } else {
                    // Exponential moving average
                    const alpha = 0.1;
                    estimator.estimatedBandwidth = 
                        alpha * newEstimate + (1 - alpha) * estimator.estimatedBandwidth;
                    
                    // Update confidence based on stability
                    const variation = Math.abs(newEstimate - estimator.estimatedBandwidth) / estimator.estimatedBandwidth;
                    estimator.confidence = Math.max(0.1, Math.min(1.0, 1.0 - variation));
                }
            }
            
            // Update smoothed RTT
            if (candidateStats && candidateStats.currentRoundTripTime !== undefined) {
                const rtt = candidateStats.currentRoundTripTime * 1000;
                if (estimator.smoothedRtt === 0) {
                    estimator.smoothedRtt = rtt;
                    estimator.rttVariance = rtt / 2;
                } else {
                    const alpha = 0.125;
                    const beta = 0.25;
                    const rttDiff = Math.abs(rtt - estimator.smoothedRtt);
                    
                    estimator.rttVariance = (1 - beta) * estimator.rttVariance + beta * rttDiff;
                    estimator.smoothedRtt = (1 - alpha) * estimator.smoothedRtt + alpha * rtt;
                }
            }
        }
        
        function runDelayBasedController(candidateStats, timestamp) {
            const controller = gccController.delayBasedController;
            
            if (!candidateStats || candidateStats.currentRoundTripTime === undefined) {
                return 'normal';
            }
            
            const rtt = candidateStats.currentRoundTripTime * 1000; // Convert to ms
            
            // Add to delay history
            controller.delayHistory.push({ timestamp, rtt });
            if (controller.delayHistory.length > controller.maxHistorySize) {
                controller.delayHistory.shift();
            }
            
            // Calculate delay variation if we have enough samples
            if (controller.delayHistory.length < 5) {
                return 'normal';
            }
            
            // Calculate trend using linear regression
            const n = controller.delayHistory.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;
            
            for (let i = 0; i < n; i++) {
                const x = i;
                const y = controller.delayHistory[i].rtt;
                sumX += x;
                sumY += y;
                sumXY += x * y;
                sumX2 += x * x;
            }
            
            const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const delayGradient = slope;
            
            // Apply Kalman-like filter
            controller.offset = controller.slope * delayGradient + (1 - controller.slope) * controller.prevOffset;
            controller.prevOffset = controller.offset;
            
            // Determine hypothesis
            if (controller.offset > controller.threshold) {
                controller.hypothesis = 'decrease';
                return 'congested';
            } else if (controller.offset < -controller.threshold) {
                controller.hypothesis = 'increase';
                return 'underused';
            } else {
                controller.hypothesis = 'normal';
                return 'normal';
            }
        }
        
        function runLossBasedController(videoStats, timestamp) {
            const controller = gccController.lossBasedController;
            
            // Calculate loss rate
            if (videoStats.packetsLost !== undefined && videoStats.packetsReceived !== undefined) {
                const totalPackets = videoStats.packetsLost + videoStats.packetsReceived;
                controller.lossRate = totalPackets > 0 ? videoStats.packetsLost / totalPackets : 0;
            }
            
            // Determine signal based on loss rate
            if (controller.lossRate > controller.lossThreshold) {
                return 'decrease';
            } else if (controller.lossRate < controller.lossThreshold * 0.5) {
                return 'normal';
            } else {
                return 'normal';
            }
        }
        
        function updateTargetBitrate(delaySignal, lossSignal, timestamp) {
            const controller = gccController.rateController;
            const currentBitrate = gccController.currentBitrate;
            let newTargetBitrate = gccController.targetBitrate;
            
            // Loss-based adjustments have priority
            if (lossSignal === 'decrease') {
                newTargetBitrate = Math.max(
                    gccController.minBitrate,
                    currentBitrate * gccController.lossBasedController.decreaseFactor
                );
                gccController.delayBasedController.hypothesis = 'normal'; // Reset delay-based state
            } else {
                // Delay-based adjustments
                if (delaySignal === 'congested') {
                    newTargetBitrate = Math.max(
                        gccController.minBitrate,
                        currentBitrate * controller.decreaseRate
                    );
                } else if (delaySignal === 'underused') {
                    const increaseAmount = Math.min(
                        controller.maxIncrease,
                        Math.max(controller.minIncrease, currentBitrate * 0.05)
                    );
                    newTargetBitrate = Math.min(
                        gccController.maxBitrate,
                        currentBitrate + increaseAmount
                    );
                } else if (delaySignal === 'normal' && lossSignal === 'normal') {
                    // Gradual increase when network is stable
                    if (timestamp - controller.lastUpdateTime > 1000) { // Every second
                        const increaseAmount = Math.min(
                            controller.increaseRate,
                            currentBitrate * 0.02
                        );
                        newTargetBitrate = Math.min(
                            gccController.maxBitrate,
                            currentBitrate + increaseAmount
                        );
                        controller.lastUpdateTime = timestamp;
                    }
                }
            }
            
            // Apply bandwidth estimation constraints
            const estimatedBandwidth = gccController.bandwidthEstimator.estimatedBandwidth;
            if (estimatedBandwidth > 0 && gccController.bandwidthEstimator.confidence > 0.7) {
                newTargetBitrate = Math.min(newTargetBitrate, estimatedBandwidth * 0.85); // Use 85% of estimated bandwidth
            }
            
            gccController.targetBitrate = newTargetBitrate;
        }
        
        function applyGCCBitrate() {
            const targetBitrate = gccController.targetBitrate;
            const currentBitrate = gccController.currentBitrate;
            
            // Gradual bitrate adaptation to avoid sudden changes
            const maxChange = currentBitrate * 0.1; // Max 10% change per update
            let newBitrate;
            
            if (Math.abs(targetBitrate - currentBitrate) <= maxChange) {
                newBitrate = targetBitrate;
            } else if (targetBitrate > currentBitrate) {
                newBitrate = currentBitrate + maxChange;
            } else {
                newBitrate = currentBitrate - maxChange;
            }
            
            gccController.currentBitrate = newBitrate;
            
            // Apply to all peer connections
            Object.entries(peerConnections).forEach(([userId, pc]) => {
                const videoSender = pc.getSenders().find(sender => 
                    sender.track && sender.track.kind === 'video'
                );
                if (videoSender) {
                    applyGCCBitrateConstraints(videoSender, newBitrate);
                }
            });
        }
        
        async function applyGCCBitrateConstraints(sender, bitrate) {
            try {
                const params = sender.getParameters();
                
                if (params.encodings && params.encodings.length > 0) {
                    params.encodings[0].maxBitrate = Math.round(bitrate);
                    await sender.setParameters(params);
                }
            } catch (error) {
                console.error('Error applying GCC bitrate constraints:', error);
            }
        }
        
        function updateGCCDisplay() {
            const currentBitrate = Math.round(gccController.currentBitrate / 1000); // Convert to kbps
            const targetBitrate = Math.round(gccController.targetBitrate / 1000);
            const estimatedBandwidth = Math.round(gccController.bandwidthEstimator.estimatedBandwidth / 1000);
            
            // Update bitrate display
            const bitrateValue = document.getElementById('bitrateValue');
            const targetBitrateValue = document.getElementById('targetBitrateValue');
            const bandwidthEstimate = document.getElementById('bandwidthEstimate');
            
            if (bitrateValue) bitrateValue.textContent = currentBitrate;
            if (targetBitrateValue) targetBitrateValue.textContent = targetBitrate;
            if (bandwidthEstimate) bandwidthEstimate.textContent = estimatedBandwidth || '-';
            
            // Update bitrate bar (relative to max bitrate)
            const bitrateFill = document.getElementById('bitrateFill');
            if (bitrateFill) {
                const percentage = (gccController.currentBitrate / gccController.maxBitrate) * 100;
                bitrateFill.style.width = Math.min(100, percentage) + '%';
            }
            
            // Update GCC status signal
            const gccSignal = document.getElementById('gccSignal');
            const gccState = document.getElementById('gccState');
            
            if (gccSignal && gccState) {
                const hypothesis = gccController.delayBasedController.hypothesis;
                const lossRate = gccController.lossBasedController.lossRate;
                
                // Remove all classes
                gccSignal.classList.remove('good', 'warning', 'poor');
                
                if (lossRate > 0.05 || hypothesis === 'decrease') {
                    gccSignal.classList.add('poor');
                    gccState.textContent = 'Congested';
                } else if (lossRate > 0.01 || hypothesis === 'normal') {
                    gccSignal.classList.add('warning');
                    gccState.textContent = 'Stable';
                } else {
                    gccSignal.classList.add('good');
                    gccState.textContent = 'Optimal';
                }
            }
        }
        
        function toggleGCC() {
            gccEnabled = !gccEnabled;
            const toggle = document.getElementById('gccToggle');
            
            if (toggle) {
                toggle.classList.toggle('active', gccEnabled);
            }
            
            console.log('Google Congestion Control:', gccEnabled ? 'enabled' : 'disabled');
            
            if (!gccEnabled) {
                // Reset to default bitrate when disabled
                gccController.currentBitrate = qualityLevels[currentQualityLevel].bitrate;
                gccController.targetBitrate = qualityLevels[currentQualityLevel].bitrate;
                applyGCCBitrate();
            }
        }
        
        function showQualityChangeNotification(oldLevel, newLevel) {
            const qualityNames = ['Very Low', 'Low', 'Medium', 'High', 'Very High'];
            const direction = newLevel > oldLevel ? 'ðŸ“ˆ' : 'ðŸ“‰';
            const message = `${direction} Quality adjusted: ${qualityNames[oldLevel]} â†’ ${qualityNames[newLevel]}`;
            
            // Create notification element
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.8);
                color: white;
                padding: 10px 15px;
                border-radius: 8px;
                font-size: 14px;
                z-index: 10000;
                animation: slideIn 0.3s ease-out;
            `;
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Remove notification after 3 seconds
            setTimeout(() => {
                if (notification.parentNode) {
                    notification.parentNode.removeChild(notification);
                }
            }, 3000);
        }
        
        function resetAudioSettings() {
            // Reset all toggles
            enhancedNoiseReduction = false;
            highPassFilterEnabled = false;
            compressionEnabled = false;
            voiceIsolationEnabled = false;
            currentGain = 1.0;
            noiseGateThreshold = 0.2;
            effectIntensity = 0.5;
            activeEffects.clear();
            
            // Reset UI toggles
            enhancedNoiseToggle.classList.remove('active');
            highPassToggle.classList.remove('active');
            compressionToggle.classList.remove('active');
            if (voiceIsolationToggle) voiceIsolationToggle.classList.remove('active');
            
            // Reset sliders
            gainSlider.value = 1.0;
            noiseGateSlider.value = 20;
            if (effectIntensitySlider) effectIntensitySlider.value = 50;
            
            // Reset EQ to flat
            applyEQPreset('flat');
            
            // Reset effect buttons
            document.querySelectorAll('.effect-btn').forEach(btn => btn.classList.remove('active'));
            
            // Reconnect audio chain
            if (audioProcessingContext && sourceNode && destinationNode) {
                try {
                    sourceNode.disconnect();
                    connectAudioProcessingChain();
                    console.log('Audio settings reset to defaults');
                    alert('All audio settings reset to defaults');
                } catch (e) {
                    console.error('Error resetting audio settings:', e);
                }
            }
        }
        
        function initializeMobileUI() {
            console.log('Initializing mobile UI, isMobile:', isMobile, 'isIOS:', isIOS, 'isAndroid:', isAndroid);
            
            // Ensure viewport is properly set for mobile
            const viewport = document.querySelector('meta[name="viewport"]');
            if (!viewport) {
                const newViewport = document.createElement('meta');
                newViewport.name = 'viewport';
                newViewport.content = 'width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover';
                document.head.appendChild(newViewport);
            }
            
            // Initialize mobile chat toggle functionality
            initializeMobileChatToggle();
            
            if (isMobile) {
                // Add mobile class to screen button
                const screenButton = document.getElementById('screenBtn');
                if (screenButton) {
                    screenButton.classList.add('mobile-disabled');
                    screenButton.disabled = true;
                    screenButton.title = 'Screen sharing is not supported on mobile devices';
                    screenButton.style.opacity = '0.3';
                }
                
                // Hide screen controls button on mobile
                const screenControlsBtn = document.querySelector('[onclick="toggleScreenControls()"]');
                if (screenControlsBtn) {
                    screenControlsBtn.style.display = 'none';
                }
                
                // Initialize camera switch button for mobile
                if (cameraSwitchBtn) {
                    cameraSwitchBtn.style.display = 'inline-block';
                    cameraSwitchBtn.title = 'Switch between front and back camera';
                    console.log('Camera switch button enabled for mobile');
                }
                
                // Add mobile-specific styling
                document.body.classList.add('mobile-device');
                
                console.log('Mobile UI initialized - screen sharing disabled');
            } else {
                // Initialize camera switch button for desktop
                if (cameraSwitchBtn) {
                    // Show camera switch button if multiple cameras are available
                    enumerateCameras().then(() => {
                        if (availableCameras.length > 1) {
                            cameraSwitchBtn.style.display = 'inline-block';
                            cameraSwitchBtn.title = 'Switch between available cameras';
                            console.log('Camera switch button enabled for desktop - multiple cameras detected');
                        } else {
                            cameraSwitchBtn.style.display = 'none';
                            console.log('Camera switch button hidden - only one camera available');
                        }
                    }).catch(error => {
                        console.log('Error enumerating cameras on desktop:', error);
                        cameraSwitchBtn.style.display = 'none';
                    });
                }
                
                console.log('Desktop UI - screen sharing available');
            }
        }
        
        // Initialize WebGL effects when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            console.log('DOM loaded, checking WebGL support...');
            
            // Initialize mobile-specific UI
            initializeMobileUI();
            
            // Initialize chat foreground icon
            initChatForegroundIcon();
            
            // Auto-expand video room if chat is visible (foreground mode)
            setTimeout(() => {
                const chatSidebar = document.getElementById('chatSidebar');
                if (chatSidebar && !chatSidebar.classList.contains('hidden') && !chatSidebar.classList.contains('collapsed')) {
                    // Force chat to foreground immediately
                    forceChatToForeground();
                    expandVideoConferencingRoom();
                    console.log('Auto-expanded video room on page load - chat forced to foreground');
                }
            }, 1000);
            
            // Initialize video grid layout
            adjustVideoGridLayout();
            updateVideoGridLayout();
            
            // Initialize chat layout system
            initializeChatLayoutSystem();
            
            // Add window resize listener for responsive adjustments
            window.addEventListener('resize', () => {
                setTimeout(() => {
                    adjustVideoGridLayout();
                    updateVideoGridLayout();
                }, 100);
            });
            
            // Add keyboard shortcuts
            document.addEventListener('keydown', handleKeyboardShortcuts);
            
            // Check WebGL support
            const canvas = document.createElement('canvas');
            const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
            
            if (gl) {
                console.log('WebGL supported');
                updateWebGLStatus('WebGL Supported', true);
            } else {
                console.warn('WebGL not supported');
                updateWebGLStatus('WebGL Not Supported', false);
            }
            
            // Add debug logging for class availability
            setTimeout(() => {
                console.log('WebGLVideoEffects available:', typeof WebGLVideoEffects !== 'undefined');
                console.log('ARMaskGenerator available:', typeof ARMaskGenerator !== 'undefined');
                
                if (typeof WebGLVideoEffects === 'undefined') {
                    console.error('WebGLVideoEffects class not loaded. Check if /static/webgl-video-effects.js is accessible.');
                }
                if (typeof ARMaskGenerator === 'undefined') {
                    console.error('ARMaskGenerator class not loaded. Check if /static/ar-mask-generator.js is accessible.');
                }
            }, 1000);
            
            // Initialize camera switch button click handler
            if (cameraSwitchBtn) {
                cameraSwitchBtn.addEventListener('click', switchCamera);
                console.log('Camera switch button click handler attached');
            }
            
            // Add global click handler to unfocus videos when clicking outside
            document.addEventListener('click', (e) => {
                // Check if clicked element is not a video container or inside one
                const clickedVideoContainer = e.target.closest('.video-container');
                if (!clickedVideoContainer && focusedVideoUserId) {
                    unfocusAllVideos();
                }
            });
        });
        
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (isCallActive) {
                endCall();
            }
            socket.emit('leave_room', { room_id: roomId });
        });
        
        // Enhanced utility functions
        function copyRoomId() {
            const roomIdValue = document.querySelector('.room-id-value');
            const roomIdText = roomIdValue.textContent;
            
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(roomIdText).then(() => {
                    showToast('Room ID copied to clipboard! ðŸ“‹', 'success');
                    
                    // Add visual feedback
                    roomIdValue.style.transform = 'scale(1.1)';
                    roomIdValue.style.background = 'rgba(76, 175, 80, 0.3)';
                    setTimeout(() => {
                        roomIdValue.style.transform = '';
                        roomIdValue.style.background = '';
                    }, 300);
                }).catch(() => {
                    fallbackCopyToClipboard(roomIdText);
                });
            } else {
                fallbackCopyToClipboard(roomIdText);
            }
        }
        
        function fallbackCopyToClipboard(text) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();
            
            try {
                document.execCommand('copy');
                showToast('Room ID copied to clipboard! ðŸ“‹', 'success');
            } catch (err) {
                showToast('Failed to copy Room ID. Please copy manually.', 'error');
            }
            
            document.body.removeChild(textArea);
        }
        
        // Enhanced button feedback
        function addButtonFeedback(button, message, type = 'info') {
            button.style.transform = 'scale(0.95)';
            setTimeout(() => {
                button.style.transform = '';
                if (message) {
                    showToast(message, type);
                }
            }, 150);
        }
        
        // Add enhanced feedback to existing functions
        const originalToggleAudio = window.toggleAudio;
        if (typeof originalToggleAudio === 'function') {
            window.toggleAudio = function() {
                originalToggleAudio();
                const audioBtn = document.getElementById('audioBtn');
                if (audioBtn.classList.contains('muted')) {
                    showToast('Microphone muted ðŸŽ¤', 'warning');
                } else {
                    showToast('Microphone activated ðŸŽ¤', 'success');
                }
            };
        }
        
        const originalToggleVideo = window.toggleVideo;
        if (typeof originalToggleVideo === 'function') {
            window.toggleVideo = function() {
                originalToggleVideo();
                const videoBtn = document.getElementById('videoBtn');
                if (videoBtn.classList.contains('muted')) {
                    showToast('Camera turned off ðŸ“¹', 'warning');
                } else {
                    showToast('Camera activated ðŸ“¹', 'success');
                }
            };
        }
        
        // Initialize Chat Layout System
        function initializeChatLayoutSystem() {
            const chatSidebar = document.getElementById('chatSidebar');
            const container = document.querySelector('.container');
            
            // Set initial state
            updateVideoGridLayout();
            
            // Check if this is a mobile device
            const isMobileDevice = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            const isMobileScreen = window.innerWidth <= 768;
            
            // On mobile devices or mobile screen sizes, start with expanded chat but don't auto-toggle
            if (isMobileDevice || isMobileScreen) {
                // On mobile, keep chat in normal state by default - user can manually toggle
                updateLayoutStatus('ðŸ“± Mobile Layout', 'Tap chat toggle button to minimize');
                showToast('ðŸ’¬ Chat is ready - tap toggle button to minimize if needed', 'info');
            } else {
                // On desktop, auto-minimize chat on smaller screens for better video view
                if (window.innerWidth <= 1200 && !chatSidebar.classList.contains('collapsed')) {
                    setTimeout(() => {
                        toggleChat();
                        showToast('Chat minimized for better video view', 'info');
                    }, 1000);
                }
            }
            
            // Add resize listener for adaptive behavior (but not for mobile devices)
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    // Only auto-toggle on desktop, not on mobile devices
                    if (!isMobileDevice && !(/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent))) {
                        if (window.innerWidth <= 1000 && !chatSidebar.classList.contains('collapsed')) {
                            toggleChat();
                        } else if (window.innerWidth > 1400 && chatSidebar.classList.contains('collapsed')) {
                            toggleChat();
                        }
                    }
                    updateVideoGridLayout();
                }, 250);
            });
            
            // Add orientation change listener for mobile devices
            if (isMobileDevice) {
                window.addEventListener('orientationchange', () => {
                    setTimeout(() => {
                        updateVideoGridLayout();
                        // Don't auto-toggle chat on orientation change, just update layout
                        showToast('Layout updated for new orientation', 'info');
                    }, 500); // Wait for orientation change to complete
                });
            }
        }
        
        // Keyboard Shortcuts Handler
        function handleKeyboardShortcuts(event) {
            // Check if user is typing in an input field
            if (event.target.tagName === 'INPUT' || event.target.tagName === 'TEXTAREA') {
                return;
            }
            
            switch(event.key.toLowerCase()) {
                case 'c':
                    event.preventDefault();
                    toggleChat();
                    break;
                case 'f':
                    event.preventDefault();
                    doubleTapChat();
                    break;
                case 'v':
                    event.preventDefault();
                    if (typeof toggleVideo === 'function') toggleVideo();
                    break;
                case 'm':
                    event.preventDefault();
                    if (typeof toggleAudio === 'function') toggleAudio();
                    break;
                case 's':
                    event.preventDefault();
                    if (typeof toggleScreenShare === 'function') toggleScreenShare();
                    break;
                case 'escape':
                    event.preventDefault();
                    // Restore normal layout if in any special mode
                    const chatSidebar = document.getElementById('chatSidebar');
                    const container = document.querySelector('.container');
                    if (chatSidebar.classList.contains('hidden')) {
                        doubleTapChat();
                    } else if (chatSidebar.classList.contains('collapsed')) {
                        toggleChat();
                    }
                    break;
                case '1':
                case '2':
                case '3':
                case '4':
                case '5':
                case '6':
                case '7':
                case '8':
                case '9':
                    event.preventDefault();
                    // Quick chat state switcher
                    const stateNumber = parseInt(event.key);
                    quickChatState(stateNumber);
                    break;
            }
        }
        
        // Quick Chat State Switcher
        function quickChatState(state) {
            const chatSidebar = document.getElementById('chatSidebar');
            const container = document.querySelector('.container');
            const toggleBtn = document.getElementById('chatToggleBtn');
            
            // Reset all states first
            chatSidebar.classList.remove('collapsed', 'hidden', 'expanded');
            container.classList.remove('chat-collapsed', 'fullscreen-video', 'chat-expanded');
            
            switch(state) {
                case 1: // Normal
                    toggleBtn.textContent = 'â—€ï¸';
                    toggleBtn.title = 'Minimize Chat';
                    updateLayoutStatus('ðŸ’» Normal Layout Mode', 'Balanced layout');
                    showToast('Chat: Normal mode', 'info');
                    break;
                case 2: // Minimized
                    chatSidebar.classList.add('collapsed');
                    container.classList.add('chat-collapsed');
                    toggleBtn.textContent = 'â–¶ï¸';
                    toggleBtn.title = 'Expand Chat';
                    updateLayoutStatus('ðŸ“± Compact Layout Mode', 'More space for video');
                    showToast('Chat: Minimized mode', 'info');
                    break;
                case 3: // Hidden/Full Video
                    chatSidebar.classList.add('hidden');
                    container.classList.add('fullscreen-video');
                    toggleBtn.textContent = 'ðŸ’¬';
                    toggleBtn.title = 'Show Chat';
                    updateLayoutStatus('ðŸŽ¬ Full Video Mode', 'Maximum video space');
                    showToast('Chat: Full video mode', 'info');
                    break;
                case 4: // Expanded
                    chatSidebar.classList.add('expanded');
                    container.classList.add('chat-expanded');
                    toggleBtn.textContent = 'â—€ï¸';
                    toggleBtn.title = 'Minimize Chat';
                    updateLayoutStatus('ðŸ’¬ Chat-Focused Mode', 'Enhanced chat experience');
                    showToast('Chat: Expanded mode', 'info');
                    break;
            }
            
            setTimeout(() => {
                updateVideoGridLayout();
                window.dispatchEvent(new Event('resize'));
            }, 100);
        }
        
        // Show keyboard shortcuts help
        function showKeyboardHelp() {
            const helpText = `
            Keyboard Shortcuts:
            C - Toggle Chat
            F - Full Video Mode
            V - Toggle Video
            M - Toggle Microphone
            S - Toggle Screen Share
            ESC - Reset Layout
            1 - Normal Chat
            2 - Minimize Chat
            3 - Hide Chat (Full Video)
            4 - Expand Chat
            `;
            showToast(helpText, 'info', 8000);
        }
        
        // Add help button functionality (if help button exists)
        setTimeout(() => {
            const helpBtn = document.querySelector('[title="Help"]');
            if (helpBtn) {
                helpBtn.addEventListener('click', showKeyboardHelp);
            }
        }, 1000);
        
    </script>
    
    <!-- Video Zoom Overlay - Positioned outside container for proper overlay -->
    <div class="video-zoom-overlay" id="videoZoomOverlay">
        <div class="video-zoom-container" id="videoZoomContainer">
            <!-- Zoomed video will be inserted here dynamically -->
        </div>
    </div>
    
</body>
</html>
